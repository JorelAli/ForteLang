options {
	STATIC = false;
}

PARSER_BEGIN(ForteLang)

import java.util.LinkedList;
import java.util.LinkedHashMap;
import java.util.HashMap;
import java.util.ListIterator;
import java.util.Stack;
import java.util.Scanner;

import java.util.regex.Pattern;

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;

import javax.swing.JOptionPane;
import javax.swing.UIManager;

import java.math.BigDecimal;
import java.math.RoundingMode;

public class ForteLang {
	
	/** Static fields */
	static String fileName;
	static boolean LOGGING_ENABLE = true;
	static Scanner globalScanner = null;
	public static int innerComments = 0;
	
	final static boolean GENERATE_DOCS = false;
	static LinkedHashMap<String, String> docs = new LinkedHashMap<String, String>();

	static void printSECD()                   { print("SECD"); }
	static void printSECD(Object o)           { print("SECD", o); }
	static void printSECD(String s, Object o) { print("SECD", s, o); }

	static void printEVAL()                   { print("EVAL"); }
	static void printEVAL(Object o)           { print("EVAL", o); }
	static void printEVAL(String s, Object o) { print("EVAL", s, o); }

	static void printOPEX()                   { print("OPEX"); }
	static void printOPEX(Object o)           { print("OPEX", o); }
	static void printOPEX(String s, Object o) { print("OPEX", s, o); }
	
	static void print(String title)           { print(title, "", ""); }
	static void print(String title, Object o) { print(title, "", o); }
	static void print(String title, String init, Object o) {
	  	if(LOGGING_ENABLE) {
		  	System.out.println("[" + title + "] " + init + (init.isEmpty() ? "" : " ") + o);
	  	}
	}

	static Scanner getGlobalScanner() {
		if(globalScanner == null) {
			globalScanner = new Scanner(System.in);
		}
		return globalScanner;
	}

	static String prettifyOutput(Object result) {
		if(result instanceof String) {
			return "\"" + result + "\"";
		} else if(result instanceof BigDecimal) {
		  	BigDecimal d = (BigDecimal) result;
			if(d.stripTrailingZeros().scale() > 0) {
				result = d.doubleValue();
			}
		}
		return String.valueOf(result);
	}

	/** Main method */
	public static void main(String[] args) throws ParseException, FileNotFoundException {
	  	boolean replMode = false;
	  	for(String str : args) {
			if(str.equals("-repl")) {
				replMode = true;
			}
	  	}
	  	
	  	if(args.length < 1) {
	  	  	System.out.println("Usage: java ForteLang <File>");
			return;
	  	}

	  	if(replMode) {
			LOGGING_ENABLE = false;
			System.out.println("Welcome to the ForteLang repl (v0.0.1). Type :help for help.");
			System.out.println();
			Scanner scanner = getGlobalScanner();
			repl: while(true) {
			  	System.out.print("fl-repl> ");
				String input = null;
				try { 
					input = scanner.nextLine();
				} catch(Exception e) { scanner.close(); }
				switch(input) {
					case ":help":
						System.out.println("The following commands are available:");
						System.out.println();
						System.out.println("  :q\tExit ForteLang repl");
						System.out.println();
						continue repl;
					case ":q":
						break repl;
				}
				
				try { 
					Object result = new ForteLang(new ByteArrayInputStream(input.getBytes())).input();
					System.out.println("=> " + prettifyOutput(result) + "\n");
				} catch(Error e) {
					System.out.println("=>> Error, invalid input \"" + input + "\"");
					System.out.println(e.getMessage() + "\n");
				} catch(Exception e) {
					System.out.println("=>> Error, invalid input \"" + input + "\"");
					System.out.println(e.getMessage() + "\n");
				}
			}
	  	} else {
			File file = new File(args[0]);
		  	fileName = file.getName();
			try {
			  	/* Run the parser */
	
				Object result = new ForteLang(new FileInputStream(file)).input();
				System.out.println();
				System.out.println("=== Evaluation complete ===");
				System.out.println("==> " + prettifyOutput(result));

				if(GENERATE_DOCS) {
					System.out.println();
					System.out.println("=== Generated documentation ===");
					for(String key : docs.keySet()) {
						System.out.println(key);
						System.out.println("  " + docs.get(key).replace("\n", "\n  "));
					}
				}
				
			} catch(Exception e) {
			  	e.printStackTrace();
			  	return;
			}
	  	}
	}

	static class EvaluationException extends Exception {
		public EvaluationException(String message) {
			super(message);
		}
	}

	/** Helper functions */

	static String location(Token token) {
 		return " (Line " + token.beginLine + " in " + fileName + ")";
	}

	static String parseString(Token str) {
		return str.image.substring(1, str.image.length() - 1);
	}

	/** Other declared objects */

	static class OperatorParser {

		enum Operator { BOOLEAN, NUMERICAL, SET, COMPARATOR, CONCAT, CONTAINS, SELECT };

		Operator operatorKind;
		String op;
		Scope scope;
	  
		public OperatorParser(Token operator, Scope scope) throws Exception {
		  	this.scope = scope;
		  	
			switch(operator.kind) {
				case ForteLangConstants.BOOLEAN_OP:
					operatorKind = Operator.BOOLEAN;
					break;
				case ForteLangConstants.OP:
					operatorKind = Operator.NUMERICAL;
					break;
				case ForteLangConstants.SET_OP:
					operatorKind = Operator.SET;
					break;
				case ForteLangConstants.COMPARATOR_OP:
					operatorKind = Operator.COMPARATOR;
					break;
				case ForteLangConstants.CONCAT:
					operatorKind = Operator.CONCAT;
					break;
				case ForteLangConstants.CONTAINS:
					operatorKind = Operator.CONTAINS;
					break;
				case ForteLangConstants.SELECT:
					operatorKind = Operator.SELECT;
					break;
				default:
					throw new Exception ("Invalid operator for OperatorParser: " + operator.image);
			}
			op = operator.image;
		}

		public Object apply(Object o1, Object o2) throws Exception {

			if(operatorKind != Operator.SELECT) { 
			  	if (o1 instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr left part", o1);
					o1 = evaluate(scope, o1);
			  	}
	
			  	if (o2 instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr right part", o2);
					o2 = evaluate(scope, o2);
			  	}
		 	}
			
			switch(operatorKind) {
				case BOOLEAN:
					return applyBoolean((boolean) o1, (boolean) o2);
				case NUMERICAL:
					return applyNumber((BigDecimal) o1, (BigDecimal) o2);
				case SET:
					return applySetObjects((FL_Set) o1, (FL_Set) o2);
				case COMPARATOR:
					return applyComparator(o1, o2);
				case CONCAT:
					return applyConcat(o1, o2);
				case CONTAINS:
					return applyContains(o1, o2);
				case SELECT:
					return applySelect(o1, o2);
			}
			throw new Exception ("Failed to apply any operators");
		}

		public Object applySelect(Object o1, Object o2) throws Exception {
		  
	  	  	printEVAL("EvalOpExpr left part", o1);
			o1 = evaluate(scope, o1);
		  	
		  	if(o1 instanceof FL_Set) {
				FL_Set set = (FL_Set) o1;
				if(o2 instanceof FL_String) {
				  	Object result = set.get(((FL_String) o2).stringValue());
				  	if(result == null) {
						throw new Exception("Cannot find element \"" + o2 + "\" in set containing " + set.keySet());
				  	} else { 
						return result;
					}
				} else if (o2 instanceof FL_FunctionCall) {
				  	FL_FunctionCall func = (FL_FunctionCall) o2;
				  	if(func.getInitFunction() instanceof FL_Var) {
						FL_Var var = (FL_Var) func.getInitFunction();
						Object result = set.get(var.getName());
					  	if(result == null) {
							throw new Exception("Cannot find element \"" + var.getName() + "\" in set containing " + set.keySet());
					  	} else { 
							return result;
						}
				  	} else {
						if(func.getInitFunction() instanceof Evaluatable) {
							return applySelect(o1, evaluate(scope, func));
						} else {
							throw new Exception("Cannot select from a set using a " + func.getInitFunction().getClass().getName());
						}
				  	}
				} else if (o2 instanceof Evaluatable) {
					return applySelect(o1, evaluate(scope, o2));
				} else { 
					throw new Exception("Cannot select from a set using a " + o2.getClass().getName());
				}
		  	} else {
				throw new Exception("Cannot select from an object that's not a set");
		  	}
		}

		public Object applyContains(Object o1, Object o2) throws Exception {
			if(o1 instanceof FL_List) {
				FL_List l1 = (FL_List) o1;
				return l1.contains(o2); //TODO: Fix this
			} else if(o1 instanceof FL_String) {
				FL_String s1 = (FL_String) o1;
				if(o2 instanceof FL_String) {
				  	FL_String s2 = (FL_String) o2;
					return s1.stringValue().contains(s2.stringValue());
				}
			} else if(o1 instanceof FL_Set) {
				FL_Set s1 = (FL_Set) o1;
				if(o2 instanceof FL_String) {
				  	FL_String s2 = (FL_String) o2;
					return s1.containsKey(s2.stringValue());
				}
			}
			throw new Exception("Cannot check for existance within a " + o1.getClass().getName());
		}

		public Object applyConcat(Object o1, Object o2) throws Exception {
		  	if(o1 instanceof LinkedList && o2 instanceof LinkedList) {
		  	  	LinkedList l1 = (LinkedList) o1;
		  	  	LinkedList l2 = (LinkedList) o2;
				l1.addAll(l2);
				return l1;
			} else {
				throw new Exception("Cannot concatenate " + o1.getClass().getName() + " with " + o2.getClass().getName());
			}
		}

		public boolean applyComparator(Object o1, Object o2) throws Exception {
			switch(op) {
				case ">":
					return ((BigDecimal) o1).compareTo((BigDecimal) o2) > 0;
				case "<":
					return ((BigDecimal) o1).compareTo((BigDecimal) o2) < 0;
				case "<=":
					return ((BigDecimal) o1).compareTo((BigDecimal) o2) <= 0;
				case ">=":
					return ((BigDecimal) o1).compareTo((BigDecimal) o2) >= 0;
				case "==":
					System.out.println("Comparing " + o1 + " to " + o2);
					if(o1 instanceof Evaluatable || o2 instanceof Evaluatable) {
						Evaluatable e1 = (Evaluatable) o1;
						return e1.equalsWithScope(o2, scope);
					} 
					return o1.equals(o2);
				case "!=":
					if(o1 instanceof Evaluatable || o2 instanceof Evaluatable) {
						Evaluatable e1 = (Evaluatable) o1;
						return !e1.equalsWithScope(o2, scope);
					} 
					return !o1.equals(o2);
			}
			throw new Exception ("Invalid operator (expected comparator operator");
		}

		public BigDecimal applyNumber(BigDecimal f1, BigDecimal f2) throws Exception {
			if(operatorKind != Operator.NUMERICAL) {
				throw new Exception("Invalid operator (expected numerical operator)");
		  	}

			switch(op) {
				case "+":
					return f1.add(f2);
				case "*":
					return f1.multiply(f2);
				case "-":
					return f1.subtract(f2);
				case "/":
					return f1.divide(f2, 128, RoundingMode.HALF_DOWN);
				case "%":
					return f1.remainder(f2);
			}
			throw new Exception("Invalid operator " + op);
		}

		public boolean applyBoolean(boolean b1, boolean b2) throws Exception {
			if(operatorKind != Operator.BOOLEAN) {
				throw new Exception("Invalid operator (expected boolean operator)");
		  	}
			switch(op) {
				case "||":
					return b1 || b2;
				case "&&":
					return b1 && b2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public FL_Set applySetObjects(FL_Set s1, FL_Set s2) throws Exception {
			if(operatorKind != Operator.SET) {
				throw new Exception("Invalid operator (expected set operator)");
		  	}

			FL_Set newSet = s1.copy();
		  	
			switch(op) {
			  	//union
				case "/+": {
				  	newSet.putAll(s2);
					break;
				}
				//intersect
				case "/-": {
				  	newSet.putAll(s1);
				  	newSet.keySet().retainAll(s2.keySet());
				  	for(String key : newSet.keySet()) {
						newSet.put(key, s1.get(key));
				  	}
					break;
				}
				//difference
				case "//": {
				  	for(String key : s2.keySet()) {
						newSet.remove(key);
				  	}
					break;
				}
			}
			return newSet;
		} 
	}

	public static Object secd(FL_FunctionCall functionCall, Scope globalScope) throws Exception {
		System.out.println();
		class Dump {
			Stack<Object> stack;
			LinkedList<Object> control;
			HashMap<String, Object> environment;
	
			public Dump(Stack<Object> s, LinkedList<Object> control, HashMap<String, Object> env) {
				this.stack = s;
				this.control = control;
				this.environment = env;
			}
		}

		class ApplyObj {
			@Override
		  	public String toString() {
		    	return "ap";
		    }
		}
		
	  	Stack<Object> stack = new Stack<Object>();
	  	HashMap<String, Object> environment = new HashMap<String, Object>();
	  	//environment.putAll(globalScope); //TODO: Make sure this isn't busted
	  	LinkedList<Object> control = new LinkedList<Object>();
	  	Stack<Dump> dump = new Stack<Dump>();

	  	//Convert to reverse polish
		control.add(functionCall.getInitFunction());
		for(Object object : functionCall.getArguments()) {
			control.add(object);
			control.add(new ApplyObj());
		}
		printSECD("Initial control: ", control);

		Object controlItem = null;

		do {
			while(!control.isEmpty()) {
				controlItem = control.pop();
				printSECD("Popped: ", controlItem);
	
				if(controlItem instanceof ApplyObj) {
					//Begin application
					printSECD();
					printSECD("Applying... ");
	
					//Pop two items from the top of the stack
					Object value = stack.pop();

					Object potentialFunction = stack.pop();
					
					FL_Function lambda = null;
					if(potentialFunction instanceof FL_Function) {
						lambda = (FL_Function) potentialFunction;
					} else if(potentialFunction instanceof FL_FunctionCall) {
						FL_FunctionCall lambdaCall = (FL_FunctionCall) potentialFunction;
						lambda = (FL_Function) lambdaCall.getInitFunction();
					}

					printSECD("Value: ", value);
					printSECD("potentialFunction: ", potentialFunction);
					
	
					//Bind it properly in the current environment
					//Type check
					Type type = lambda.getParameter().getType();
					if(!Type.isType(value, type)) {
						throw new Exception("Invalid type. Expected " + type + ", but got " + value.getClass().getSimpleName()); 
					}
					
					environment.put(lambda.getParameter().getName(), value);
					Object result = lambda.getExpression();

					printSECD("Added complete. Result: " + result.getClass().getName(), result);
	
					//If the result is an abstraction, dump it
					if(result instanceof FL_FunctionCall) {
					    //Dump
					  	printSECD("Beginning dump...");
					  	@SuppressWarnings("unchecked") 
						Dump newDump = new Dump(
						  (Stack<Object>) stack.clone(),
						  new LinkedList<Object>(control),
						  new HashMap<String, Object>(environment)
						);
						dump.push(newDump);
			
						stack.clear();
						control.clear();
						environment.clear();
			
						control.add(result);
					} else {
					  	//Push result on the stack
						stack.push(result);
					}
				} else {
					printSECD("Evaluated control item... ", controlItem.getClass().getName());
				  	
					//If it's a FL_Var, evaluate it
					if(controlItem instanceof Evaluatable && !(controlItem instanceof FL_Function)) {
					  	//TODO: Check here - this might not be properly evaluating the inputs
					  	printSECD("Evaluated control item as: ", controlItem);	
						controlItem = evaluate(globalScope, controlItem);
						printSECD("Evaluated control item as: ", controlItem);
					}
					//Otherwise, don't. Push the control item on the stack
					stack.push(controlItem);
					printSECD("Added control item to stack.");
				}
			}

			if(!dump.isEmpty()) {
			  	printSECD("Restoring from dump");
			  	Dump restoredDump = dump.pop();

			  	while(!stack.isEmpty()) {
					restoredDump.stack.push(stack.pop());
			  	}

			  	stack = restoredDump.stack;
			  	control = restoredDump.control;
			  	environment.putAll(restoredDump.environment);
			  	printSECD("Dump restored");
			}

		} while(!control.isEmpty() || !dump.isEmpty());

		Scope newEnv = new Scope(environment);
		newEnv.putAll(functionCall.getLocalScope());
		printSECD("SECD ended with ", stack.peek());
		printSECD("SECD scope was ", newEnv);
		return evaluate(newEnv, stack.pop());
	}

	public static Object evaluateOpExpr(Scope scope, FL_OpExpr flOpExpr) throws Exception {
	  	System.out.println();
		printOPEX("About to evaluate OpExpr");
	  	printOPEX();		
		printOPEX(flOpExpr);

		printOPEX("Phase 1: Flattening");

		class LeftBracket { public String toString () { return "("; }}
		class RightBracket { public String toString () { return ")"; }}

		class OpFlattener {
			private final FL_OpExpr expr;
	
			public OpFlattener(FL_OpExpr expr) {
				this.expr = expr;
			}

			public LinkedList<Object> flatten() {
				LinkedList<Object> elements = new LinkedList<Object>();
				if(expr.hasBrackets()) {
					elements.add(new LeftBracket());
				}

				if(expr.getLeftExpr() instanceof FL_OpExpr) {
					elements.addAll(new OpFlattener((FL_OpExpr) expr.getLeftExpr()).flatten());
				} else {
					elements.add(expr.getLeftExpr());
				}

				elements.add(expr.getOperator());

				if(expr.getRightExpr() instanceof FL_OpExpr) {
					elements.addAll(new OpFlattener((FL_OpExpr) expr.getRightExpr()).flatten());
				} else {
					elements.add(expr.getRightExpr());
				}

				if(expr.hasBrackets()) {
					elements.add(new RightBracket());
				}
				return elements;
			}
		}

		class Op {
			private Token token;
		  
			public Op(Object token) {
				this.token = (Token) token;
			}

			public int precedence() {
				switch(token.image) {
					case ".": return 10;
					case "?": return 9;
					case "++": return 8;
					case "*":
					case "%":
					case "/": return 7;
					case "+":
					case "-": return 6;
					case "/+":
					case "/-":
					case "//": return 5;
					case "<":
					case "<=":
					case ">":
					case ">=": return 4;
					case "==":
					case "!=": return 3;
					case "&&":
					case "||": return 2;
				}
				return 0;
			}

			public boolean rightAssociative(Object other) {
			  	switch(token.image) {
					case ".":
						return token.image.equals(((Token) other).image);
			  	}
			  	return false;
			}
		}

		//Flatten the elements of OpExpr into a linked list for evaluation
		LinkedList<Object> elements = new OpFlattener(flOpExpr).flatten();
		printOPEX("\t\tFlattened: ", elements);
		
		printOPEX("Phase 2: Shunting-yard");

		Stack<Object> stack = new Stack<Object>();
		LinkedList<Object> output = new LinkedList<Object>();
		while(!elements.isEmpty()) {
		  	Object element = elements.pop();
		  	if(element instanceof Token) {
				while(
				  	!stack.isEmpty() &&
					stack.peek() instanceof Token &&
					(					  new Op(stack.peek()).precedence() > new Op(element).precedence()
					  || new Op(stack.peek()).rightAssociative(element) 
					)
				) {
					output.add(stack.pop());
				}
				
				stack.push(element);
		  	} else if(element instanceof LeftBracket) {
				stack.push(element);
		  	} else if(element instanceof RightBracket) {
				while(!(stack.peek() instanceof LeftBracket)) {
					output.add(stack.pop());
				}
				stack.pop();
		  	} else { //It's a "number"
				output.add(element);
		  	}
		}
		while(!stack.isEmpty()) {
			output.add(stack.pop());
		}
		
		printOPEX("\t\tFinished Shunting Yard: ", output);
		printOPEX("Phase 3: Evaluation");

		Stack<Object> evalStack = new Stack<Object>();
		while(!output.isEmpty()) {
			evalStack.push(output.pop());
			if(evalStack.peek() instanceof Token) {
				Token operator = (Token) evalStack.pop();
				Object secondExpr = evalStack.pop();
				Object firstExpr = evalStack.pop();
				
				Object result = new OperatorParser(operator, scope).apply(firstExpr, secondExpr);
				evalStack.push(result);
			}
		}

		Object result = evalStack.pop();
		printOPEX("\t\tFinished evaluation: ", result);

		if(result instanceof Evaluatable) {
			return evaluate(scope, result);
		} else { 
			return result;
		}
	}
	
	/**
	 * Main evaluation method. Evaluates an expression given a
	 * "scope", which is an FL_Set. An FL_Set is used as opposed
	 * to a regular HashMap (for example) because an FL_Set contains
	 * information about the current purity of the scope. This is
	 * thus used to check for purity in evaluation which cannot be
	 * determined during the parse phase.
	 */
	public static Object evaluate(Scope scope, Object expression) throws Exception {
	  	scope = scope.copy();
//		System.out.println(scope);
	  	if(expression instanceof Evaluatable) {
			printEVAL("Evaluating " + expression + " (" + expression.getClass().getSimpleName() + ")");
	  	  	
	  	  	if(expression instanceof FL_Builtin) {
				FL_Builtin builtin = (FL_Builtin) expression;
				Object builtinParam = evaluate(scope, builtin.getParameter());
				switch(builtin.getType()) {
					case IMPORT:
						File file = new File(((FL_String) builtinParam).stringValue());
						return new ForteLang(new FileInputStream(file)).input();
					case PRINT:
						System.out.println(((FL_String) builtinParam).stringValue());
						return builtinParam;
					case EXEC:
						break;
					case HEAD:
						if(!(builtinParam instanceof LinkedList)) {
							throw new EvaluationException("head function requires a list as a parameter");
						} else {
						  	LinkedList list = ((LinkedList) builtinParam);
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the head of the list");
						  	}
						  	return evaluate(scope, list.getFirst());
						} 
					case TAIL:
						if(!(builtinParam instanceof LinkedList)) {
							throw new Exception("tail function requires a list as a parameter, not a " + builtinParam.getClass().getName());
						} else {
						  	LinkedList list = ((LinkedList) builtinParam);
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the tail of the list");
						  	}
						  	if(builtinParam instanceof FL_List) {
								return new FL_List(list.subList(1, list.size()));
						  	} else if(builtinParam instanceof FL_String) {
								return new FL_String(list.subList(1, list.size()));
						  	}
						  	
						}
					case INPUT:
						if(!(builtinParam instanceof FL_String)) {
							throw new EvaluationException("Expected a string for input");
						}
						System.out.println("[@input] " + ((FL_String) builtinParam).stringValue());
						System.out.print("@input> ");
						return getGlobalScanner().nextLine();
					case INPUTBOX:
						if(!(builtinParam instanceof FL_String)) {
							throw new EvaluationException("Expected a string for inputbox");
						}
						UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
						String inputBox = JOptionPane.showInputDialog(null, ((FL_String) builtinParam).stringValue(), "ForteLang @inputbox", -1);
						return (inputBox == null ? "" : inputBox);
				}
	  	  	  
			} else

			if(expression instanceof FL_Function) {
			  	FL_Function function = (FL_Function) expression;
			  	FL_FunctionCall newFunctionCall = new FL_FunctionCall();
			  	newFunctionCall.setInitFunction(function);
			  	
				return newFunctionCall;
			} else
			if(expression instanceof FL_FunctionCall) {
				printEVAL();
				FL_FunctionCall call = (FL_FunctionCall) expression;

				if(!(call.getInitFunction() instanceof FL_Function)) {
				  	// It's a function name, which needs to be resolved
				  	FL_Var functionName = (FL_Var) call.getInitFunction(); 
					Object function = scope.get(functionName.getName());

					if(function == null) {
						throw new Exception("Function \"" + functionName.getName() + "\" has not been declared!");
					} else {
						if(function instanceof FL_FunctionCall) {
						  	printEVAL("Adding " + functionName + " to FunctionCall's scope");
						  	call.getLocalScope().put(functionName.getName(), function);
							call.setInitFunction(((FL_FunctionCall) function).getInitFunction());
						} else {
							printEVAL("Reading from closure... ", function.getClass().getName());
						}
					}
				}
				
				if(call.getArguments().isEmpty()) {
				  	System.out.println("Evaluating because arguments are empty...");
					return evaluate(scope, call.getInitFunction());
				}

				
				if(call.getInitFunction() instanceof FL_Function) {
					printEVAL("About to evaluate the following: ");
					printEVAL(call.getInitFunction());

					printEVAL();
					printEVAL("Starting SECD machine");
					printEVAL();

					return secd(call, scope);
					
				} else {
				  	printEVAL("Avoiding the SECD machine, because of type ", call.getInitFunction().getClass().getName());
				  	if(call.getInitFunction() instanceof Evaluatable) {
						return evaluate(scope, call.getInitFunction());
				  	} else {
						return call.getInitFunction();
				  	}
				}

			} else if(expression instanceof FL_Guards) {
				FL_Guards guards = (FL_Guards) expression;
				for(Object guardExpr : guards.getStatements().keySet()) {
					Object result = evaluate(scope, guardExpr);
					if(result instanceof Boolean) {
						boolean resultBool = (boolean) result;
						if(!resultBool) {
							continue;
						} else {
							return evaluate(scope, guards.getStatements().get(guardExpr));
						}
					} else {
						throw new Exception(result + " is not a valid Boolean object in guard expression!");
					}
				}
				return evaluate(scope, guards.getFinalStatement());
			} else if(expression instanceof FL_Match) {
				FL_Match match = (FL_Match) expression;

				Object matchOn = evaluate(scope, match.getMatchOn());
				
				for(Object matchExpr : match.getStatements().keySet()) {
					Object result = evaluate(scope, matchExpr);

					if(result instanceof Pattern && matchOn instanceof FL_String) {
						Pattern pattern = (Pattern) result;
						if(pattern.matcher(((FL_String) matchOn).stringValue()).matches()) {
							return evaluate(scope, match.getStatements().get(matchExpr));
						}
					} else if(matchOn.equals(result)) {
						return evaluate(scope, match.getStatements().get(matchExpr));
					}
				}
				return evaluate(scope, match.getFinalStatement());
			} else if(expression instanceof FL_Var) {
				FL_Var flVar = (FL_Var) expression;
				Object var = scope.get(flVar.getName());
				while(var instanceof FL_Var) {
					var = scope.get(((FL_Var) var).getName());
				}
				if(var == null) {
					throw new Exception("Could not find function \"" + flVar.getName() + "\" in the program!");
				}
				if(var instanceof FL_Function) {
					printEVAL("\"" + flVar.getName() + "\" evaluates to a lambda, therefore not resolving");
					return var;
				} else { 
					printEVAL("Resolving: " + flVar.getName() + " => ", var);
					return evaluate(scope, var);
				}
			} else if(expression instanceof FL_OpExpr) {
			  	return evaluateOpExpr(scope, (FL_OpExpr) expression);
			} else if(expression instanceof FL_List) {
				FL_List list = (FL_List) expression;
				ListIterator<Object> iterator = list.listIterator(0);
				while(iterator.hasNext()) {
					Object expr = iterator.next();
					iterator.set(evaluate(scope, expr));
				}
				return list;
			} else if(expression instanceof FL_Set) {
				return expression;
			} else if(expression instanceof FL_IncludedSet) {
			  	FL_IncludedSet incSet = (FL_IncludedSet) expression;
				scope.putAll(incSet.getFLSet());
				return evaluate(scope, incSet.getExpression());
			} else if(expression instanceof FL_String) {
			  	return expression;
			}
			throw new Exception("Not implemented yet, could not evaluate: " + expression);
	  	} else {
	  	  return expression;
	  	}
	}

}

PARSER_END(ForteLang)

//Operators
TOKEN : { < COMPARATOR_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" > }
TOKEN : { < BOOLEAN_OP : "||" | "&&" > }
TOKEN : { < SET_OP : "/+" | "/-" | "//" > }
TOKEN : { < OP : "+" | "*" | "-" | "/" | "%" > }
TOKEN : { < CONCAT : "++" > }
TOKEN : { < SELECT : "." > }
TOKEN : { < CONTAINS : "?" > }

//Data types
TOKEN : { < NUMBER : ("-")? (["0"-"9"])+ > }
TOKEN : { < FLOATING_POINT_NUMBER : <NUMBER>"."<NUMBER> > }
TOKEN : { < BOOLEAN : "true" | "false" > } 
TOKEN : { < STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >}
TOKEN : { < REGEX_STRING : "'" ("\\" ~[] | ~["'", "\\"])* "'" >}

//Keywords
TOKEN : { < INCLUDE : "include" > }
TOKEN : { < IN : "in" > }
TOKEN : { < MATCH : "match" > }

//Built-in functions
TOKEN : { < IMPORT : "@import" > }
TOKEN : { < EXEC : "@exec" > }
TOKEN : { < PRINT : "@print" > }
TOKEN : { < INPUT : "@input" > }
TOKEN : { < INPUTBOX : "@inputbox" > }

TOKEN : { < HEAD : "head" > }
TOKEN : { < TAIL : "tail" > }

//Brackets
TOKEN : { < OPENBRACKET : "(" > }
TOKEN : { < CLOSEBRACKET : ")" > }

//Lists
TOKEN : { < OPENSBRACKET : "[" > }
TOKEN : { < CLOSESBRACKET : "]" > }
TOKEN : { < COMMA : "," > }

//Enums
TOKEN : { < CAPS : (["A"-"Z", "_"])+ > }
TOKEN : { < ENUM_OPEN : " {|" > }
TOKEN : { < ENUM_CLOSE : "|}" > }

//Sets
TOKEN : { < EQUALS : "=" > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < OPENCBRACKET : "{" > }
TOKEN : { < CLOSECBRACKET : "}" > }

//Types
TOKEN : { < NUM : "num" > } 
TOKEN : { < LST : "list" > }
TOKEN : { < SET : "set" > }
TOKEN : { < FUN : "func" > }
TOKEN : { < BOO : "bool" > }
TOKEN : { < STR : "str" > }
TOKEN : { < COLON : ":" > }

//Functions
TOKEN : { < VAR_NAME : ["A"-"Z", "a"-"z", "@"] (["A"-"Z", "a"-"z", "0"-"9", "'"])* > }
TOKEN : { < FUNCTION_ARROW : "->" > }
TOKEN : { < GUARD_START : "|>" > }
TOKEN : { < GUARD : "|" > }
TOKEN : { < GUARD_ARROW : "->>" > }

//Comments
SPECIAL_TOKEN : { < "##|" (~["\r", "\n"])* > }
SKIP : { < "##" (~["\r", "\n"])* > }
SKIP : { "#[" : BlockComment }
<BlockComment> SKIP : { < "#[" > { ForteLang.innerComments++; } }
<BlockComment> MORE : { < ~[] > }
<BlockComment> SKIP : { < "]#" >
	{
  		if(ForteLang.innerComments == 0) {
	  	    SwitchTo(DEFAULT);
	  	} else {
  	    	ForteLang.innerComments--;
  		}
	}
}

//Whitespace
SKIP : { "\n" | "\r" | " " | "\t" }

/** Main endpoint */
Object input() throws Exception : { Object expression; Token eof; } {
  expression = enclosedExpression()
  <EOF>
  {

	if(LOGGING_ENABLE) {
		System.out.println();
		System.out.println("=== Parsing complete ===");
		System.out.println();
	}

    Object result = null;
    if(expression instanceof FL_IncludedSet) {
    	FL_IncludedSet flIS = (FL_IncludedSet) expression;
    	result = evaluate(new Scope(flIS.getFLSet()), flIS.getExpression());
    } else {
		result = evaluate(new Scope(), expression);
    }
	
    return result;
  }
}

Token anyOperator() throws Exception : { Token op; } {
	  op = <BOOLEAN_OP>    { return op; }
	| op = <OP>            { return op; }
	| op = <SET_OP>        { return op; }
	| op = <COMPARATOR_OP> { return op; }
	| op = <CONCAT>        { return op; }
	| op = <CONTAINS>      { return op; }
	| op = <SELECT>        { return op; }
}

Type anyType() throws Exception : { Token type; } {
	(	    type = <NUM>
	  | type = <LST>
	  | type = <SET>
	  | type = <FUN>
	  | type = <BOO>
	  | type = <STR>
	)
	{
		switch(token.kind) {
			case ForteLangConstants.NUM:
				return Type.NUMBER;
			case ForteLangConstants.LST:
				return Type.LIST;
			case ForteLangConstants.SET:
				return Type.SET;
			case ForteLangConstants.FUN:
				return Type.FUNCTION;
			case ForteLangConstants.BOO:
				return Type.BOOLEAN;
			case ForteLangConstants.STR:
				return Type.STRING;
			default:
				return Type.ANY;
		}
	}
	
}

FL_IncludedSet includedSet() throws Exception : { FL_Set set; Object expression; } {
	<INCLUDE>
	set = set()
	<IN>
	expression = enclosedExpression()
	{ return new FL_IncludedSet(set, expression); }
}

FL_Set set() throws Exception : { FL_Set set; Token setDeclaration; Token attrName; Object attrValue; } {
  	{ set = new FL_Set(); }
	setDeclaration = <OPENCBRACKET>
	(
	  	attrName = <VAR_NAME>
	  	{
	  	  if (attrName.specialToken != null && GENERATE_DOCS) {
		  	Token tmp_t = attrName.specialToken;
		  	while (tmp_t.specialToken != null) tmp_t = tmp_t.specialToken;
		    // The above line walks back the special token chain until it
		    // reaches the first special token after the previous regular
		    // token.
		    StringBuilder docBuilder = new StringBuilder();
		  	while (tmp_t != null) {
		  	  	String documentation = tmp_t.image;
		    	docBuilder.append(documentation.substring(3, documentation.length()));
		    	docBuilder.append("\n");
		    	tmp_t = tmp_t.next;
		  	}
		  	docs.put(attrName.image, docBuilder.toString());
		    // The above loop now walks the special token chain in the forward
		    // direction printing them in the process.
		}
	  	}
	  	<EQUALS>
	  	attrValue = enclosedExpression()
	  	<SEMICOLON>
	  	{ set.put(attrName.image, attrValue); }
	)*
	<CLOSECBRACKET>
	{
	  //	  set.checkPurity(setDeclaration);
	  return set;
	}
}

FL_Function lambda() throws Exception : { Token paramName; Object innerExpression; Type type; } {
  	{ type = Type.ANY; }
	(
		(			paramName = <VAR_NAME>(<COLON> type = anyType())?
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
		)
		|
		(
			<OPENBRACKET>
			paramName = <VAR_NAME>(<COLON> type = anyType())?
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
			<CLOSEBRACKET>
		)
	)
	  
	{
	  return new FL_Function(new FL_TypedParam(paramName.image, type), innerExpression);
	}
}

FL_List list() throws Exception : { FL_List list; Object nextItem; } {
	{ list = new FL_List(); }

  	//Open bracket
  	<OPENSBRACKET> (
  	  
		//Empty list		<CLOSESBRACKET> { return list; }
		|
		//Non-empty list
		nextItem = enclosedExpression()
		{ list.add(nextItem); }
		
		(LOOKAHEAD(2) <COMMA>
			nextItem = enclosedExpression()
			{ list.add(nextItem); }
		)*
		<CLOSESBRACKET>
	)
	{ return list; }
}

BigDecimal number() throws Exception : { Token value; } {
	  value = <NUMBER> 				  { return new BigDecimal(value.image); }
	| value = <FLOATING_POINT_NUMBER> { return new BigDecimal(value.image); }
}

/** Expressions */
Object enclosedExpression() throws Exception : { Object result; Token vName;  } {
	LOOKAHEAD(3)
	result = opExpression(false) {return result; }
	| (
	  <OPENBRACKET>
	  result = opExpression(true) 
	  <CLOSEBRACKET>
	   { return result; }
	)
}

Object expression() throws Exception : { Object result; Token token; } {
  	LOOKAHEAD(3)
  	result = functionCall() { return result; }
    | result = set() { return result; }
	| result = lambda() { return result; }
	| result = includedSet() { return result; }
	| result = list() { return result; }
	| result = number() { return result; }
	| result = guards() { return result; }
	| result = match() { return result; }
	| token = <STRING> { return new FL_String(parseString(token)); }
	| token = <REGEX_STRING> { return Pattern.compile(parseString(token)); }
	| token = <BOOLEAN> { return Boolean.parseBoolean(token.image); }
	| result = builtinFunctions() { return result; }
}

Object opExpression(boolean bracketed) throws Exception : {
  Object leftExpr;
  Object rightExpr = null;
  Token operator = null;
} {
  
  	( LOOKAHEAD(3)  	  leftExpr = expression()
  	  | <OPENBRACKET> leftExpr = opExpression(true) <CLOSEBRACKET>
  	)
	(
	  LOOKAHEAD(2)
	  operator = anyOperator()
	  rightExpr = enclosedExpression()
	)?
	
	{
		if(operator != null) {
			return new FL_OpExpr(leftExpr, rightExpr, operator, bracketed);
		} else {
			return leftExpr;
		}
	}
}

FL_FunctionCall functionCall() throws Exception : { FL_FunctionCall result; Object param; Token varName; Object lambda; } {
  	{
		varName = null;
		lambda = null;
  	}
  	(
  	  LOOKAHEAD(2)
  	  lambda = lambda()  	  | varName = <VAR_NAME> 
  	)
  	{
  	   	result = new FL_FunctionCall();
  	   	if(varName != null) { 
			result.setInitFunction(new FL_Var(varName.image));
		} else {
			result.setInitFunction(lambda);
		}
  	}
	(
	  LOOKAHEAD(2)
	  param = enclosedExpression()
	  { result.getArguments().add(param); }
	)*
	{ return result; }
}

Object builtinFunctions() throws Exception : { Object param; Token stringToken; } {
	<IMPORT>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.IMPORT, param); }
    | <PRINT> param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.PRINT, param); }
	| <EXEC>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.EXEC, param); }
	| <HEAD>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.HEAD, param); }
	| <TAIL>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.TAIL, param); }
	| <INPUT>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.INPUT, param); }
	| <INPUTBOX>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.INPUTBOX, param); }
}

FL_Guards guards() throws Exception : {
  FL_Guards guards = new FL_Guards();
  Object predicate;
  Object expression;
} {
  	<GUARD_START>
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ guards.addStatement(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	expression = enclosedExpression()
	{
	  guards.setFinalStatement(expression);
	  return guards;
	}
}

FL_Match match() throws Exception : {
  FL_Match match;
  Object statement;
  
  Object predicate;
  Object expression;
  Object finalExpression;
} {
	<MATCH>
	statement = enclosedExpression()
	{ match = new FL_Match(statement); }
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ match.addStatement(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	expression = enclosedExpression()
	{
	  match.setFinalStatement(expression);
	  return match;
	}
}
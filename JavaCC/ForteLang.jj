options {
	STATIC = false;
}

PARSER_BEGIN(ForteLang)

import java.util.LinkedList;
import java.util.HashMap;
import java.util.ListIterator;
import java.util.Stack;
import java.util.Scanner;

import java.util.regex.Pattern;

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;

import javax.swing.JOptionPane;
import javax.swing.UIManager;

public class ForteLang {
	
	/** Static fields */
	static String fileName;
	static boolean LOGGING_ENABLE = true;
	static Scanner globalScanner = null;

	static void printSECD()                   { print("SECD"); }
	static void printSECD(Object o)           { print("SECD", o); }
	static void printSECD(String s, Object o) { print("SECD", s, o); }

	static void printEVAL()                   { print("EVAL"); }
	static void printEVAL(Object o)           { print("EVAL", o); }
	static void printEVAL(String s, Object o) { print("EVAL", s, o); }

	static void printOPEX()                   { print("OPEX"); }
	static void printOPEX(Object o)           { print("OPEX", o); }
	static void printOPEX(String s, Object o) { print("OPEX", s, o); }
	
	static void print(String title)           { print(title, "", ""); }
	static void print(String title, Object o) { print(title, "", o); }
	static void print(String title, String init, Object o) {
	  	if(LOGGING_ENABLE) {
		  	System.out.println("[" + title + "] " + init + (init.isEmpty() ? "" : " ") + o);
	  	}
	}

	static Scanner getGlobalScanner() {
		if(globalScanner == null) {
			globalScanner = new Scanner(System.in);
		}
		return globalScanner;
	}

	static String prettifyOutput(Object result) {
		if(result instanceof String) {
			return "\"" + result + "\"";
		} else if(result instanceof Double) {
		  	double d = (double) result;
			if((d % 1) == 0) {
				result = (long) d;
			}
		}
		return String.valueOf(result);
	}

	/** Main method */
	public static void main(String[] args) throws ParseException, FileNotFoundException {
	  	boolean replMode = false;
	  	for(String str : args) {
			if(str.equals("-repl")) {
				replMode = true;
			}
	  	}
	  	
	  	if(args.length < 1) {
	  	  	System.out.println("Usage: java ForteLang <File>");
			return;
	  	}

	  	if(replMode) {
			LOGGING_ENABLE = false;
			System.out.println("Welcome to the ForteLang repl (v0.0.1). Type :help for help.");
			System.out.println();
			Scanner scanner = getGlobalScanner();
			repl: while(true) {
			  	System.out.print("fl-repl> ");
				String input = null;
				try { 
					input = scanner.nextLine();
				} catch(Exception e) { scanner.close(); }
				switch(input) {
					case ":help":
						System.out.println("The following commands are available:");
						System.out.println();
						System.out.println("  :q\tExit ForteLang repl");
						System.out.println();
						continue repl;
					case ":q":
						break repl;
				}
				
				try { 
					Object result = new ForteLang(new ByteArrayInputStream(input.getBytes())).input();
					System.out.println("=> " + prettifyOutput(result) + "\n");
				} catch(Error e) {
					System.out.println("=>> Error, invalid input \"" + input + "\"");
					System.out.println(e.getMessage() + "\n");
				} catch(Exception e) {
					System.out.println("=>> Error, invalid input \"" + input + "\"");
					System.out.println(e.getMessage() + "\n");
				}
			}
	  	} else {
			File file = new File(args[0]);
		  	fileName = file.getName();
			try {
			  	/* Run the parser */
	
				Object result = new ForteLang(new FileInputStream(file)).input();
				System.out.println();
				System.out.println("=== Evaluation complete ===");
				System.out.println("==> " + prettifyOutput(result));
				
			} catch(Exception e) {
			  	e.printStackTrace();
			  	return;
			}
	  	}
	}

	static class EvaluationException extends Exception {
		public EvaluationException(String message) {
			super(message);
		}
	}

	/** Helper functions */

	static String location(Token token) {
 		return " (Line " + token.beginLine + " in " + fileName + ")";
	}

	static String parseString(Token str) {
		return str.image.substring(1, str.image.length() - 1);
	}

	/** Other declared objects */

	static class OperatorParser {

		enum Operator { BOOLEAN, NUMERICAL, SET, COMPARATOR, CONCAT, CONTAINS, SELECT };

		Operator operatorKind;
		String op;
		FL_Set scope;
	  
		public OperatorParser(Token operator, FL_Set scope) throws Exception {
		  	this.scope = scope;
		  	
			switch(operator.kind) {
				case ForteLangConstants.BOOLEAN_OP:
					operatorKind = Operator.BOOLEAN;
					break;
				case ForteLangConstants.OP:
					operatorKind = Operator.NUMERICAL;
					break;
				case ForteLangConstants.SET_OP:
					operatorKind = Operator.SET;
					break;
				case ForteLangConstants.COMPARATOR_OP:
					operatorKind = Operator.COMPARATOR;
					break;
				case ForteLangConstants.CONCAT:
					operatorKind = Operator.CONCAT;
					break;
				case ForteLangConstants.CONTAINS:
					operatorKind = Operator.CONTAINS;
					break;
				case ForteLangConstants.SELECT:
					operatorKind = Operator.SELECT;
					break;
				default:
					throw new Exception ("Invalid operator for OperatorParser: " + operator.image);
			}
			op = operator.image;
		}

		public Object apply(Object o1, Object o2) throws Exception {

			if(operatorKind != Operator.SELECT) { 
			  	if (o1 instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr left part", o1);
					o1 = evaluate(scope, o1);
			  	}
	
			  	if (o2 instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr right part", o2);
					o2 = evaluate(scope, o2);
			  	}
		 	}
			
			switch(operatorKind) {
				case BOOLEAN:
					return applyBoolean((boolean) o1, (boolean) o2);
				case NUMERICAL:
					return applyDouble((double) o1, (double) o2);
				case SET:
					return applySetObjects((FL_Set) o1, (FL_Set) o2);
				case COMPARATOR:
					return applyComparator(o1, o2);
				case CONCAT:
					return applyConcat(o1, o2);
				case CONTAINS:
					return applyContains(o1, o2);
				case SELECT:
					return applySelect(o1, o2);
			}
			throw new Exception ("Failed to apply any operators");
		}

		public Object applySelect(Object o1, Object o2) throws Exception {
		  
		  	if (o1 instanceof Evaluatable) {
		  	  	printEVAL("EvalOpExpr left part", o1);
				o1 = evaluate(scope, o1);
		  	}
		  	
		  	if(o1 instanceof FL_Set) {
				FL_Set set = (FL_Set) o1;
				if(o2 instanceof String) {
				  	Object result = set.get(String.valueOf(o2));
				  	if(result == null) {
						throw new Exception("Cannot find element \"" + o2 + "\" in set containing " + set.keySet());
				  	} else { 
						return result;
					}
				} else if (o2 instanceof FL_FunctionCall) {
				  	FL_FunctionCall func = (FL_FunctionCall) o2;
				  	if(func.getInitFunction() instanceof FL_Var) {
						FL_Var var = (FL_Var) func.getInitFunction();
						Object result = set.get(var.getName());
					  	if(result == null) {
							throw new Exception("Cannot find element \"" + var.getName() + "\" in set containing " + set.keySet());
					  	} else { 
							return result;
						}
				  	} else {
						if(func.getInitFunction() instanceof Evaluatable) {
							return applySelect(o1, evaluate(scope, func));
						} else {
							throw new Exception("Cannot select from a set using a " + func.getInitFunction().getClass().getName());
						}
				  	}
				} else if (o2 instanceof Evaluatable) {
					return applySelect(o1, evaluate(scope, o2));
				} else { 
					throw new Exception("Cannot select from a set using a " + o2.getClass().getName());
				}
		  	} else {
				throw new Exception("Cannot select from an object that's not a set");
		  	}
		}

		public Object applyContains(Object o1, Object o2) throws Exception {
			if(o1 instanceof FL_List) {
				FL_List l1 = (FL_List) o1;
				return l1.contains(o2);
			} else if(o1 instanceof FL_Set) {
				FL_Set s1 = (FL_Set) o1;
				return s1.keySet().contains(o2);
			} else {
				throw new Exception("Cannot check for existance within a " + o1.getClass().getName());
			}
		}

		public Object applyConcat(Object o1, Object o2) throws Exception {
		  	if(o1 instanceof FL_List && o2 instanceof FL_List) {
		  	  	FL_List l1 = (FL_List) o1;
		  	  	FL_List l2 = (FL_List) o2;
				l1.addAll(l2);
				return l1;
			} else if(o1 instanceof String && o2 instanceof String) {
				String s1 = (String) o1;
				String s2 = (String) o2;
				return s1 + s2;
			} else {
				throw new Exception("Cannot concatenate " + o1.getClass().getName() + " with " + o2.getClass().getName());
			}
		}

		public boolean applyComparator(Object o1, Object o2) throws Exception {
			switch(op) {
				case ">":
					return (double) o1 > (double) o2;
				case "<":
					return (double) o1 < (double) o2;
				case "<=":
					return (double) o1 <= (double) o2;
				case ">=":
					return (double) o1 >= (double) o2;
				case "==":
					return o1.equals(o2);
				case "!=":
					return !o1.equals(o2);
			}
			throw new Exception ("Invalid operator (expected comparator operator");
		}

		public double applyDouble(double f1, double f2) throws Exception {
			if(operatorKind != Operator.NUMERICAL) {
				throw new Exception("Invalid operator (expected numerical operator)");
		  	}

			switch(op) {
				case "+":
					return f1 + f2;
				case "*":
					return f1 * f2;
				case "-":
					return f1 - f2;
				case "/":
					return f1 / f2;
				case "%":
					return (int) f1 % (int) f2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public boolean applyBoolean(boolean b1, boolean b2) throws Exception {
			if(operatorKind != Operator.BOOLEAN) {
				throw new Exception("Invalid operator (expected boolean operator)");
		  	}
			switch(op) {
				case "||":
					return b1 || b2;
				case "&&":
					return b1 && b2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public FL_Set applySetObjects(FL_Set s1, FL_Set s2) throws Exception {
			if(operatorKind != Operator.SET) {
				throw new Exception("Invalid operator (expected set operator)");
		  	}

			FL_Set newSet = s1.copy();
		  	
			switch(op) {
			  	//union
				case "/+": {
				  	newSet.setImpure(s1.isImpure() || s2.isImpure());
				  	newSet.putAll(s2);
					break;
				}
				//intersect
				case "/-": {
				  	newSet.putAll(s1);
				  	newSet.keySet().retainAll(s2.keySet());
				  	for(String key : newSet.keySet()) {
						newSet.put(key, s1.get(key));
				  	}
				  	newSet.setImpure(newSet.isImpure()); 
					break;
				}
				//difference
				case "//": {
				  	for(String key : s2.keySet()) {
						newSet.remove(key);
				  	}
				  	newSet.setImpure(newSet.isImpure()); 
					break;
				}
			}
			return newSet;
		} 
	}

	public static Object secd(FL_FunctionCall functionCall, FL_Set globalScope) throws Exception {

		class Dump {
			Stack<Object> stack;
			LinkedList<Object> control;
			HashMap<String, Object> environment;
	
			public Dump(Stack<Object> s, LinkedList<Object> control, HashMap<String, Object> env) {
				this.stack = s;
				this.control = control;
				this.environment = env;
			}
		}

		class ApplyObj {
			@Override
		  	public String toString() {
		    	return "ap";
		    }
		}
		
	  	Stack<Object> stack = new Stack<Object>();
	  	HashMap<String, Object> environment = new HashMap<String, Object>();
	  	environment.putAll(globalScope); //TODO: Make sure this isn't busted
	  	LinkedList<Object> control = new LinkedList<Object>();
	  	Stack<Dump> dump = new Stack<Dump>();

	  	//Convert to reverse polish
		control.add(functionCall.getInitFunction());
		for(Object object : functionCall.getArguments()) {
			control.add(object);
			control.add(new ApplyObj());
		}
		printSECD("Initial control: ", control);

		Object controlItem = null;

		do {
			while(!control.isEmpty()) {
				controlItem = control.pop();

	
				if(controlItem instanceof ApplyObj) {
					//Begin application
					printSECD();
					printSECD("Applying...");
	
					//Pop two items from the top of the stack
					Object value = stack.pop();

					Object potentialFunction = stack.pop();
					
					FL_Function lambda = null;
					if(potentialFunction instanceof FL_Function) {
						lambda = (FL_Function) potentialFunction;
					} else if(potentialFunction instanceof FL_FunctionCall) {
						FL_FunctionCall lambdaCall = (FL_FunctionCall) potentialFunction;
						lambda = (FL_Function) lambdaCall.getInitFunction();
					}
					
	
					//Bind it properly in the current environment
					environment.put(lambda.getParameter(), value);
					Object result = lambda.getExpression();

					printSECD("Added complete. Result: ", result);
	
					//If the result is an abstraction, dump it
					if(result instanceof FL_Function) {
					    //Dump
					  	printSECD("Beginning dump...");
					  	@SuppressWarnings("unchecked") 
						Dump newDump = new Dump((Stack<Object>) stack.clone(), new LinkedList<Object>(control), new HashMap<String, Object>(environment));
						dump.push(newDump);
			
						stack.clear();
						control.clear();
						environment.clear();
			
						control.add(result);
					} else {
					  	//Push result on the stack
						stack.push(result);
					}
				} else {
					//If it's a FL_Var, evaluate it
					if(controlItem instanceof Evaluatable && !(controlItem instanceof FL_Function)) {
					  	//TODO: Check here - this might not be properly evaluating the inputs	
						controlItem = evaluate(globalScope, controlItem);
					}
					//Otherwise, don't. Push the control item on the stack
					stack.push(controlItem);
				}
			}

			if(!dump.isEmpty()) {
			  	printSECD("Restoring from dump");
			  	Dump restoredDump = dump.pop();

			  	while(!stack.isEmpty()) {
					restoredDump.stack.push(stack.pop());
			  	}

			  	stack = restoredDump.stack;
			  	control = restoredDump.control;
			  	environment.putAll(restoredDump.environment);
			  	printSECD("Dump restored");
			}

		} while(!control.isEmpty() || !dump.isEmpty());

		FL_Set newEnv = new FL_Set(false);
		newEnv.putAll(environment);
		printSECD("SECD ended with " + stack.peek());		
		return evaluate(newEnv, stack.pop());
	}

	public static Object evaluateOpExpr(FL_Set scope, FL_OpExpr flOpExpr) throws Exception {
		printOPEX("About to evaluate OpExpr:");
		printOPEX(flOpExpr);
		
	  	Object left = flOpExpr.getLeftExpr();
	  	Object right = flOpExpr.getRightExpr();
		Token operatorToUse = flOpExpr.getOperator();

		printOPEX("OpExpr to eval: " + left + " " + operatorToUse.image + " " + right);
		printOPEX("");
		printOPEX("Phase 1: Flattening");

		
		
		printOPEX("Phase 2: Shunting-yard");
		printOPEX("Phase 3: Evaluation");
	  	
	  	Object newInit = new OperatorParser(operatorToUse, scope).apply(left, right);

	  	printOPEX("OpExpr eval result: ", newInit);

	  	if(newInit instanceof Evaluatable) {
			return evaluate(scope, newInit);
	  	} else { 
		  	return newInit;
		}	
	}
	
	/**
	 * Main evaluation method. Evaluates an expression given a
	 * "scope", which is an FL_Set. An FL_Set is used as opposed
	 * to a regular HashMap (for example) because an FL_Set contains
	 * information about the current purity of the scope. This is
	 * thus used to check for purity in evaluation which cannot be
	 * determined during the parse phase.
	 */
	public static Object evaluate(FL_Set scope, Object expression) throws Exception {
	  	scope = scope.copy();
//		System.out.println(scope);
	  	if(expression instanceof Evaluatable) {
			printEVAL("Evaluating ", expression);
	  	  	
	  	  	if(expression instanceof FL_Builtin) {
				FL_Builtin builtin = (FL_Builtin) expression;
				Object builtinParam = evaluate(scope, builtin.getParameter());
				switch(builtin.getType()) {
					case IMPORT:
						File file = new File((String) builtinParam);
						return new ForteLang(new FileInputStream(file)).input();
					case PRINT:
						System.out.println((String) builtinParam);
						return builtinParam;
					case EXEC:
						break;
					case HEAD:
						if(!(builtinParam instanceof FL_List)) {
							throw new EvaluationException("head function requires a list as a parameter");
						} else {
						  	FL_List list = ((FL_List) builtinParam);
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the head of the list");
						  	}
						  	return list.getFirst();
						} 
					case TAIL:
						if(!(builtinParam instanceof FL_List)) {
							throw new Exception("tail function requires a list as a parameter, not a " + builtinParam.getClass().getName());
						} else {
						  	FL_List list = ((FL_List) builtinParam);
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the tail of the list");
						  	}
						  	return new FL_List(list.subList(1, list.size()));
						}
					case INPUT:
						if(!(builtinParam instanceof String)) {
							throw new EvaluationException("Expected a string for input");
						}
						System.out.println("[@input] " + builtinParam);
						System.out.print("@input> ");
						return getGlobalScanner().nextLine();
					case INPUTBOX:
						if(!(builtinParam instanceof String)) {
							throw new EvaluationException("Expected a string for inputbox");
						}
						UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
						String inputBox = JOptionPane.showInputDialog(null, builtinParam, "ForteLang @inputbox", -1);
						return (inputBox == null ? "" : inputBox);
				}
	  	  	  
			} else

			if(expression instanceof FL_Function) {
			  	FL_Function function = (FL_Function) expression;
			  	FL_FunctionCall newFunctionCall = new FL_FunctionCall();
			  	newFunctionCall.setInitFunction(function);
			  	
				return newFunctionCall;
			} else
			if(expression instanceof FL_FunctionCall) {
				printEVAL();
				FL_FunctionCall call = (FL_FunctionCall) expression;

				if(!(call.getInitFunction() instanceof FL_Function)) {
				  	// It's a function name, which needs to be resolved
				  	FL_Var functionName = (FL_Var) call.getInitFunction(); 
					Object function = scope.get(functionName.getName());

					if(function == null) {
						throw new Exception("Function \"" + functionName.getName() + "\" has not been declared!");
					} else {
						if(function instanceof FL_FunctionCall) {
							call.setInitFunction(((FL_FunctionCall) function).getInitFunction());
						} else {
							printEVAL("Reading from closure... ", function.getClass().getName());
						}
					}
				}
				
				if(call.getArguments().isEmpty()) {
//				  	System.out.println("Evaluating because arguments are empty...");
					return evaluate(scope, call.getInitFunction());
				}

				
				
				if(call.getInitFunction() instanceof FL_Function) {
					printEVAL("About to evaluate the following: ");
					printEVAL(call.getInitFunction());

					printEVAL();
					printEVAL("Starting SECD machine");
					printEVAL();

					return secd(call, scope);
					
				} else {
				  	printEVAL("Avoiding the SECD machine, because of type ", call.getInitFunction().getClass().getName());
				  	if(call.getInitFunction() instanceof Evaluatable) {
						return evaluate(scope, call.getInitFunction());
				  	} else {
						return call.getInitFunction();
				  	}
				}

			} else if(expression instanceof FL_Guards) {
				FL_Guards guards = (FL_Guards) expression;
				for(Object guardExpr : guards.getStatements().keySet()) {
					Object result = evaluate(scope, guardExpr);
					if(result instanceof Boolean) {
						boolean resultBool = (boolean) result;
						if(!resultBool) {
							continue;
						} else {
							return evaluate(scope, guards.getStatements().get(guardExpr));
						}
					} else {
						throw new Exception(result + " is not a valid Boolean object in guard expression!");
					}
				}
				return evaluate(scope, guards.getFinalStatement());
			} else if(expression instanceof FL_Match) {
				FL_Match match = (FL_Match) expression;

				Object matchOn = evaluate(scope, match.getMatchOn());
				
				for(Object matchExpr : match.getStatements().keySet()) {
					Object result = evaluate(scope, matchExpr);

					if(result instanceof Pattern && matchOn instanceof String) {
						Pattern pattern = (Pattern) result;
						if(pattern.matcher((String) matchOn).matches()) {
							return evaluate(scope, match.getStatements().get(matchExpr));
						}
					} else if(matchOn.equals(result)) {
						return evaluate(scope, match.getStatements().get(matchExpr));
					}
				}
				return evaluate(scope, match.getFinalStatement());
			} else if(expression instanceof FL_Var) {
				FL_Var flVar = (FL_Var) expression;
				Object var = scope.get(flVar.getName());
				while(var instanceof FL_Var) {
					var = scope.get(((FL_Var) var).getName());
				}
				if(var == null) {
					throw new Exception("Could not find function \"" + flVar.getName() + "\" in the program!");
				}
				if(var instanceof FL_Function) {
					printEVAL("\"" + flVar.getName() + "\" evaluates to a lambda, therefore not resolving");
					return var;
				} else { 
					printEVAL("Resolving: " + flVar.getName() + " => ", var);
					return evaluate(scope, var);
				}
			} else if(expression instanceof FL_OpExpr) {
			  	return evaluateOpExpr(scope, (FL_OpExpr) expression);
			} else if(expression instanceof FL_List) {
				FL_List list = (FL_List) expression;
				ListIterator<Object> iterator = list.listIterator(0);
				while(iterator.hasNext()) {
					Object expr = iterator.next();
					iterator.set(evaluate(scope, expr));
				}
				return list;
			} else if(expression instanceof FL_Set) {
			  	// TODO: Handle purity tests here!
				return expression;
			} else if(expression instanceof FL_IncludedSet) {
			  	FL_IncludedSet incSet = (FL_IncludedSet) expression;
				scope.putAll(incSet.getFLSet());
				return evaluate(scope, incSet.getExpression());
			}
			throw new Exception("Not implemented yet, could not evaluate: " + expression);
	  	} else {
	  	  return expression;
	  	}
	}

}

PARSER_END(ForteLang)

//Operators
TOKEN : { < COMPARATOR_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" > }
TOKEN : { < BOOLEAN_OP : "||" | "&&" > }
TOKEN : { < SET_OP : "/+" | "/-" | "//" > }
TOKEN : { < OP : "+" | "*" | "-" | "/" | "%" > }
TOKEN : { < CONCAT : "++" > }
TOKEN : { < SELECT : "." > }
TOKEN : { < CONTAINS : "?" > }

//Data types
TOKEN : { < NUMBER : ("-")? (["0"-"9"])+ > }
TOKEN : { < FLOATING_POINT_NUMBER : <NUMBER>"."<NUMBER> > }
TOKEN : { < BOOLEAN : "true" | "false" > } 
TOKEN : { < STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >}
TOKEN : { < REGEX_STRING : "'" ("\\" ~[] | ~["'", "\\"])* "'" >}

//Keywords
TOKEN : { < INCLUDE : "include" > }
TOKEN : { < IN : "in" > }
TOKEN : { < IMPURE : "impure" > }
TOKEN : { < MATCH : "match" > }

//Built-in functions
TOKEN : { < IMPORT : "@import" > }
TOKEN : { < EXEC : "@exec" > }
TOKEN : { < PRINT : "@print" > }
TOKEN : { < INPUT : "@input" > }
TOKEN : { < INPUTBOX : "@inputbox" > }

TOKEN : { < HEAD : "head" > }
TOKEN : { < TAIL : "tail" > }

//Brackets
TOKEN : { < OPENBRACKET : "(" > }
TOKEN : { < CLOSEBRACKET : ")" > }

//Lists
TOKEN : { < OPENSBRACKET : "[" > }
TOKEN : { < CLOSESBRACKET : "]" > }
TOKEN : { < COMMA : "," > }

//Enums
TOKEN : { < CAPS : (["A"-"Z", "_"])+ > }
TOKEN : { < ENUM_OPEN : " {|" > }
TOKEN : { < ENUM_CLOSE : "|}" > }

//Sets
TOKEN : { < EQUALS : "=" > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < OPENCBRACKET : "{" > }
TOKEN : { < CLOSECBRACKET : "}" > }

//Functions
TOKEN : { < VAR_NAME : ["A"-"Z", "a"-"z", "@"] (["A"-"Z", "a"-"z", "0"-"9", "'"])* > }
TOKEN : { < FUNCTION_ARROW : "->" > }
TOKEN : { < GUARD_START : "|>" > }
TOKEN : { < GUARD : "|" > }
TOKEN : { < GUARD_ARROW : "->>" > }

//Comments
SKIP : { < "#" (~["\r", "\n"])* > }
SKIP : { < "###" (~["#"])* "###" > }

//Whitespace
SKIP : { "\n" | "\r" | " " | "\t" }

/** Main endpoint */
Object input() throws Exception : { Object expression; } {
  expression = enclosedExpression()
  <EOF>
  {

	if(LOGGING_ENABLE) { 
		System.out.println();
		System.out.println("=== Parsing complete ===");
		System.out.println();
	}

    Object result = null;
    if(expression instanceof FL_IncludedSet) {
    	FL_IncludedSet flIS = (FL_IncludedSet) expression;
    	result = evaluate(flIS.getFLSet(), flIS.getExpression());
    } else {
		result = evaluate(new FL_Set(false), expression);
    }
	
    return result;
  }
}

Token anyOperator() throws Exception : { Token op; } {
	  op = <BOOLEAN_OP>    { return op; }
	| op = <OP>            { return op; }
	| op = <SET_OP>        { return op; }
	| op = <COMPARATOR_OP> { return op; }
	| op = <CONCAT>        { return op; }
	| op = <CONTAINS>      { return op; }
	| op = <SELECT>        { return op; }
}

FL_IncludedSet includedSet() throws Exception : { FL_Set set; Object expression; } {
	<INCLUDE>
	set = set()
	<IN>
	expression = enclosedExpression()
	{ return new FL_IncludedSet(set, expression); }
}

FL_Set set() throws Exception : { FL_Set set; Token setDeclaration; Token attrName; Object attrValue; } {
  	{ set = new FL_Set(false); }
	(
		<IMPURE>
	  	{ set.setImpure(true); }
	)?
	setDeclaration = <OPENCBRACKET>
	(
	  	attrName = <VAR_NAME>
	  	<EQUALS>
	  	attrValue = enclosedExpression()
	  	<SEMICOLON>
	  	{ set.put(attrName.image, attrValue); }
	)*
	<CLOSECBRACKET>
	{
	  //	  set.checkPurity(setDeclaration);
	  return set;
	}
}

FL_Function lambda() throws Exception : { Token paramName; Object innerExpression; } {
	(
		(			paramName = <VAR_NAME>
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
		)
		|
		(
			<OPENBRACKET>
			paramName = <VAR_NAME>
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
			<CLOSEBRACKET>
		)
	)
	  
	{ return new FL_Function(paramName.image, innerExpression); }
}

FL_List list() throws Exception : { FL_List list; Object nextItem; } {
	{ list = new FL_List(); }

  	//Open bracket
  	<OPENSBRACKET> (
  	  
		//Empty list		<CLOSESBRACKET> { return list; }
		|
		//Non-empty list
		nextItem = enclosedExpression()
		{ list.add(nextItem); }
		
		(LOOKAHEAD(2) <COMMA>
			nextItem = enclosedExpression()
			{ list.add(nextItem); }
		)*
		<CLOSESBRACKET>
	)
	{ return list; }
}

double number() throws Exception : { Token value; double f; } {
	  value = <NUMBER> 				  { return Double.valueOf(value.image); }
	| value = <FLOATING_POINT_NUMBER> { return Double.valueOf(value.image); }
}

/** Expressions */
Object enclosedExpression() throws Exception : { Object result; Token vName;  } {
	LOOKAHEAD(3)
	result = opExpression(false) {return result; }
	| (
	  <OPENBRACKET>
	  result = opExpression(true) 
	  <CLOSEBRACKET>
	   { return result; }
	)
}

Object expression() throws Exception : { Object result; } {
    LOOKAHEAD(3) result = functionCall() { return result; }
	| result = singleExpression()       { return result; }
	
}

Object singleExpression() throws Exception : { Object result; Token token; } {
	  result = set() { return result; }
	| result = lambda() { return result; }
	| result = includedSet() { return result; }
	| result = list() { return result; }
	| result = number() { return result; }
	| result = guards() { return result; }
	| result = match() { return result; }
	| token = <STRING> { return parseString(token); }
	| token = <REGEX_STRING> { return Pattern.compile(parseString(token)); }
	| token = <BOOLEAN> { return Boolean.parseBoolean(token.image); }
	| result = builtinFunctions() { return result; }
}

Object opExpression(boolean bracketed) throws Exception : {
  Object leftExpr;
  Object rightExpr = null;
  Token operator = null;
} {
  
  	( LOOKAHEAD(3)  	  leftExpr = expression()
  	  | <OPENBRACKET> leftExpr = expression() <CLOSEBRACKET>
  	)
	(
	  LOOKAHEAD(2)
	  operator = anyOperator()
	  rightExpr = enclosedExpression()
	)?
	
	{
		if(operator != null) {
		  	//TODO: Check for nested OpExprs here and
		  	//handle the order of operations.
			return new FL_OpExpr(leftExpr, rightExpr, operator, bracketed);
		} else {
			return leftExpr;
		}
	}
}

FL_FunctionCall functionCall() throws Exception : { FL_FunctionCall result; Object param; Token varName; Object lambda; } {
  	{
		varName = null;
		lambda = null;
  	}
  	(
  	  LOOKAHEAD(2)
  	  lambda = lambda()  	  | varName = <VAR_NAME> 
  	)
  	{
  	   	result = new FL_FunctionCall();
  	   	if(varName != null) { 
			result.setInitFunction(new FL_Var(varName.image));
		} else {
			result.setInitFunction(lambda);
		}
  	}
	(
	  LOOKAHEAD(2)
	  param = enclosedExpression()
	  { result.getArguments().add(param); }
	)*
	{ return result; }
}

Object builtinFunctions() throws Exception : { Object param; Token stringToken; } {
	<IMPORT>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.IMPORT, param); }
    | <PRINT> param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.PRINT, param); }
	| <EXEC>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.EXEC, param); }
	| <HEAD>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.HEAD, param); }
	| <TAIL>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.TAIL, param); }
	| <INPUT>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.INPUT, param); }
	| <INPUTBOX>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.INPUTBOX, param); }
}

FL_Guards guards() throws Exception : {
  FL_Guards guards = new FL_Guards();
  Object predicate;
  Object expression;
} {
  	<GUARD_START>
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ guards.addStatement(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	expression = enclosedExpression()
	{
	  guards.setFinalStatement(expression);
	  return guards;
	}
}

FL_Match match() throws Exception : {
  FL_Match match;
  Object statement;
  
  Object predicate;
  Object expression;
  Object finalExpression;
} {
	<MATCH>
	statement = enclosedExpression()
	{ match = new FL_Match(statement); }
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ match.addStatement(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	expression = enclosedExpression()
	{
	  match.setFinalStatement(expression);
	  return match;
	}
}
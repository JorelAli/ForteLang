PARSER_BEGIN(ForteLang)

import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import java.lang.reflect.Field;
import java.io.*;

public class ForteLang {

	static interface Evaluatable { }

	/** Class declarations */

	//Function declaration, e.g. x -> y -> x + y
	static class FL_Function implements Evaluatable {
		String parameter;
		Object expression;

		@Override public String toString() { return "FL_Function(" + parameter + ") -> (" + expression + ")"; }

		/*
		Don't forget currying!
		x -> y -> true is actually equal to x -> (y -> true)
		*/

		static class FL_Function_Builder {
			Stack<String> parameters;
			Object expression;
		  
			public FL_Function_Builder() {
				parameters = new Stack<String>();
			}

			public FL_Function build() {
			  	Object currentExpression = expression;
			  	while(!parameters.empty()) {
					FL_Function newExpression = new FL_Function();
					newExpression.parameter = parameters.pop();
					newExpression.expression = currentExpression;
					currentExpression = newExpression;
			  	}
				return (FL_Function) currentExpression;
			}
		}
	}

	//Function call, e.g. myFunc 2 3
	static class FL_Function_Call implements Evaluatable {
		FL_Var functionName;
		LinkedList<Object> arguments;

		public FL_Function_Call() {
			arguments = new LinkedList<Object>();
		}

		@Override public String toString() { return "FL_Function_Call(" + functionName + ") " + arguments; }
	}

	static class FL_Set implements Evaluatable {
		boolean impure;
		LinkedHashMap<String, Object> attributes;

		public FL_Set() { attributes = new LinkedHashMap<String, Object>(); }

		public FL_Set clone() {
			FL_Set newSet = new FL_Set();
			newSet.impure = impure;
			newSet.attributes = new LinkedHashMap<String, Object>(attributes);
			return newSet;
		}

		public void checkPurity(Token setDeclaration) throws Exception {
		  //TODO: Make this code WAY more elegant, like seriously... what even
			if(!impure) {
				for(String str: attributes.keySet()) {
					if(str.startsWith("@")) {
						throw new Exception("impure set detected and isn't declared as 'impure'");
					}
				}
				
				for(Object o : attributes.values()) {
					if(o instanceof FL_Set) {
						if(((FL_Set) o).impure) {
							throw new Exception("Set detected as impure due to inner attribute and isn't declared as 'impure'" + location(setDeclaration));
						}
					}
				}
			} else {
				for(String str: attributes.keySet()) {
					if(str.startsWith("@")) {
						return;
					}
				}
				for(Object o : attributes.values()) {
					if(o instanceof FL_Set) {
						if(((FL_Set) o).impure) {
							return;
						}
					}
				}
				throw new Exception("impure keyword detected, but the set is actually pure" + location(setDeclaration));
			}
		}

		public boolean isImpure() {
			for(String str: attributes.keySet()) {
				if(str.startsWith("@")) {
					return true;
				}
			}
			
			for(Object o : attributes.values()) {
				if(o instanceof FL_Set) {
					if(((FL_Set) o).impure) {
						return true;
					}
				}
			}
			return false;
		}

		@Override public String toString() {
		  return "FL_Set[impure=" + impure + ", attrs=" + attributes + "]";
		}
	}

	/** Helper functions */

	static String location(Token token) {
 		return " (Line " + token.beginLine + " in " + fileName + ")";
	}

	static String parseString(Token str) {
		return str.image.substring(1, str.image.length() - 1);
	}


	/** Other declared objects */

	static class FL_Guards implements Evaluatable {
		LinkedHashMap<Object, Object> statements;
		Object finalStatement;

		public FL_Guards() { statements = new LinkedHashMap<Object, Object>(); }

		@Override public String toString() {
		  return "FL_Guards[stmts=" + statements + ", finalStmt=" + finalStatement + "]";
		}
	}

	static class FL_Matches implements Evaluatable {
		LinkedHashMap<Object, Object> statements;
		Object finalStatement;

		public FL_Matches() { statements = new LinkedHashMap<Object, Object>(); }
	}

	static class FL_Enum implements Evaluatable {
		List<String> elements;
		
		public FL_Enum() { elements = new LinkedList<String>(); }
		@Override public String toString() { return "ENUM" + elements.toString(); }
	}

	static class FL_IncludedSet implements Evaluatable {
		FL_Set set;
		Object expression;

		@Override public String toString() {
		  return "FL_IncludedSet[set=" + set + ", expr=" + expression + "]";
		}
	}

	static class FL_Var implements Evaluatable {
		String name;

		public FL_Var(String name) {
			this.name = name;
		}

		@Override public String toString() {
		  return "FL_Var[name=" + name + "]";
		}
	}

	static class FL_VarOp implements Evaluatable {
		Object initVar;
		LinkedList<Token> operators;
		LinkedList<Object> expressionsToParse;

		public FL_VarOp() {
		  	operators = new LinkedList<Token>();
			expressionsToParse = new LinkedList<Object>();
		}

		@Override public String toString() {
		  if(isSingle()) {
			return "FL_VarOp[" + getSingle() + "]";
		  } else {
		  	return "FL_VarOp[init=" + initVar + "" + operators + "" + expressionsToParse + "]";
		  }
		}

		//Whether there's only an initVar and no operators/expressionsToParse
		public boolean isSingle() {
			return operators.isEmpty() && expressionsToParse.isEmpty();
		}

		public Object getSingle() {
			return initVar;
		}
	}

	/** Static fields */
	static String fileName;


	/** Main method */
	public static void main(String[] args) throws ParseException, FileNotFoundException {
	  	if(args.length != 1) {
	  	  	System.out.println("Usage: java ForteLang <File>");
			return;
	  	}

	  	File file = new File(args[0]);
	  	fileName = file.getName();
		try {
		  	/* Run the parser */

			new ForteLang(new FileInputStream(file)).input();
			
		} catch(Exception e) {
		  	e.printStackTrace();
		  	return;
		}

		//Begin interpreting system
	}

	public static <T> T print(T o) throws Exception {
	  	StringBuilder builder = new StringBuilder();
	  	builder.append(o.getClass().getName() + "[");
		for(Field f : o.getClass().getDeclaredFields()) {
			builder.append(f.getName() + ": " + f.get(o).toString() + "; ");
		}
		System.out.println(builder.append("]").toString());
		return o;
	}

	static class OperatorParser {

		enum Operator { BOOLEAN, NUMERICAL, SET, COMPARATOR };

		Operator operatorKind;
		String op;
	  
		public OperatorParser(Token operator) {
			switch(operator.kind) {
				case ForteLangConstants.BOOLEAN_OP:
					operatorKind = Operator.BOOLEAN;
					break;
				case ForteLangConstants.OP:
					operatorKind = Operator.NUMERICAL;
					break;
				case ForteLangConstants.SET_OP:
					operatorKind = Operator.SET;
					break;
				case ForteLangConstants.COMPARATOR_OP:
					operatorKind = Operator.COMPARATOR;
					break;
				default:
					operatorKind = null;
					break;
			}
			op = operator.image;
		}

		public Object apply(Object o1, Object o2) throws Exception {
			switch(operatorKind) {
				case BOOLEAN:
					return applyBoolean((boolean) o1, (boolean) o2);
				case NUMERICAL:
					return applyDouble((double) o1, (double) o2);
				case SET:
					return applySetObjects((FL_Set) o1, (FL_Set) o2);
				case COMPARATOR:
					return applyComparator(o1, o2); 
			}
			throw new Exception ("Failed to apply any operators");
		}

		public boolean applyComparator(Object o1, Object o2) throws Exception {
			switch(op) {
				case ">":
					return (double) o1 > (double) o2;
				case "<":
					return (double) o1 < (double) o2;
				case "<=":
					return (double) o1 <= (double) o2;
				case ">=":
					return (double) o1 >= (double) o2;
				case "==":
					return o1.equals(o2);
				case "!=":
					return !o1.equals(o2);
			}
			throw new Exception ("Invalid operator (expected comparator operator");
		}

		public double applyDouble(double f1, double f2) throws Exception {
			if(operatorKind != Operator.NUMERICAL) {
				throw new Exception("Invalid operator (expected numerical operator)");
		  	}

		  	//TODO: operator precedence
			switch(op) {
				case "+":
					return f1 + f2;
				case "*":
					return f1 * f2;
				case "-":
					return f1 - f2;
				case "/":
					return f1 / f2;
				case "%":
					return (int) f1 % (int) f2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public boolean applyBoolean(boolean b1, boolean b2) throws Exception {
			if(operatorKind != Operator.BOOLEAN) {
				throw new Exception("Invalid operator (expected boolean operator)");
		  	}
			switch(op) {
				case "||":
					return b1 || b2;
				case "&&":
					return b1 && b2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public FL_Set applySetObjects(FL_Set s1, FL_Set s2) throws Exception {
			if(operatorKind != Operator.SET) {
				throw new Exception("Invalid operator (expected set operator)");
		  	}

			FL_Set newSet = new FL_Set();
			newSet.attributes = new LinkedHashMap<String, Object>(s1.attributes);
		  	
			switch(op) {
			  	//union
				case "/+": {
				  	newSet.impure = (s1.impure || s2.impure);
				  	newSet.attributes.putAll(s2.attributes);
					break;
				}
				//intersect
				case "/-": {
				  	newSet.attributes.putAll(s1.attributes);
				  	newSet.attributes.keySet().retainAll(s2.attributes.keySet());
				  	for(String key : newSet.attributes.keySet()) {
						newSet.attributes.put(key, s1.attributes.get(key));
				  	}
				  	newSet.impure = newSet.isImpure(); 
					break;
				}
				//difference
				case "//": {
				  	for(String key : s2.attributes.keySet()) {
						newSet.attributes.remove(key);
				  	}
				  	newSet.impure = newSet.isImpure(); 
					break;
				}
			}
			return newSet;
		} 
	}

	public static Object evaluate(FL_Set scope, Object expression) throws Exception {
	  	scope = scope.clone();
	  	System.out.println();
//	  	System.out.println("Current scope:");
//	  	System.out.println(scope);
	  	System.out.println();
	  	if(expression instanceof Evaluatable) {
	  	  	System.out.println("Evaluating expression...");

			if(expression instanceof FL_Function_Call) {
				FL_Function_Call call = (FL_Function_Call) expression;
				Object function = scope.attributes.get(call.functionName.name);
				if(function instanceof FL_Function) {
					//FL_Function func = (FL_Function) function;

					System.out.println("About to evaluate the following: ");
					System.out.println(function);
					System.out.println("With parameters " + call.arguments);

					while(function instanceof FL_Function) {
					  	FL_Function func = (FL_Function) function;
						scope.attributes.put(func.parameter, call.arguments.pop());
						function = func.expression;
					}

					System.out.println("Applied parameters");
					System.out.println(function);
	
					return evaluate(scope, function);
				} else {
					System.err.println("Tried to perform a function call on something that's not a function");
				}

			} else if(expression instanceof FL_Guards) {
				FL_Guards guards = (FL_Guards) expression;
				
			} else if(expression instanceof FL_Var) {
				FL_Var flVar = (FL_Var) expression;
				return scope.attributes.get(flVar.name);
			} else if(expression instanceof FL_VarOp) {
				FL_VarOp flVarOp = (FL_VarOp) expression;
				if(flVarOp.isSingle()) {
					return evaluate(scope, flVarOp.getSingle());
				} else {
				  	Object init = flVarOp.initVar;
				  	Object next = flVarOp.expressionsToParse.pop();

				  	if(init instanceof Evaluatable) {
						init = evaluate(scope, init);
				  	}

				  	if(next instanceof Evaluatable) {
						next = evaluate(scope, next);
				  	}
				  	
				  	Object newInit = new OperatorParser(flVarOp.operators.pop()).apply(init, next);

				  	if(flVarOp.expressionsToParse.isEmpty()) {
						return newInit;
				  	} else {
						FL_VarOp newOp = new FL_VarOp();
						newOp.initVar = newInit;
						newOp.operators = flVarOp.operators;
						newOp.expressionsToParse = flVarOp.expressionsToParse;
						return evaluate(scope, newOp);
				  	}
				}
			}
			System.out.println("Not implemented yet, could not evaluate: " + expression);
			return null;
	  	} else {
	  	  return expression;
	  	}
	}

}

PARSER_END(ForteLang)

//Operators
TOKEN : { < COMPARATOR_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" > }
TOKEN : { < BOOLEAN_OP : "||" | "&&" > }
TOKEN : { < SET_OP : "/+" | "/-" | "//" > }
TOKEN : { < OP : "+" | "*" | "-" | "/" | "%" > }
TOKEN : { < CONCAT : "++" > }
TOKEN : { < SELECT : "." > }
TOKEN : { < CONTAINS : "?" > }

//Data types
TOKEN : { < NUMBER : ("-")? (["0"-"9"])+ > }
TOKEN : { < FLOATING_POINT_NUMBER : <NUMBER>"."<NUMBER> > }
TOKEN : { < BOOLEAN : "true" | "false" > } 
TOKEN : { < STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >}

//Keywords
TOKEN : { < INCLUDE : "include" > }
TOKEN : { < IN : "in" > }
TOKEN : { < IMPURE : "impure" > }
TOKEN : { < MATCH : "match" > }

//Built-in functions
TOKEN : { < IMPORT : "import" > }
TOKEN : { < EXEC : "@exec" > }
TOKEN : { < PRINT : "@print" > }

//Brackets
TOKEN : { < OPENBRACKET : "(" > }
TOKEN : { < CLOSEBRACKET : ")" > }

//Lists
TOKEN : { < OPENSBRACKET : "[" > }
TOKEN : { < CLOSESBRACKET : "]" > }
TOKEN : { < COMMA : "," > }

//Enums
TOKEN : { < CAPS : (["A"-"Z", "_"])+ > }
TOKEN : { < ENUM_OPEN : " {|" > }
TOKEN : { < ENUM_CLOSE : "|}" > }

//Sets
TOKEN : { < EQUALS : "=" > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < OPENCBRACKET : "{" > }
TOKEN : { < CLOSECBRACKET : "}" > }

//Functions
TOKEN : { < VAR_NAME : ["A"-"Z", "a"-"z", "@"] (["A"-"Z", "a"-"z", "0"-"9", "'"])* > }
TOKEN : { < FUNCTION_ARROW : "->" > }
TOKEN : { < GUARD : "|" > }
TOKEN : { < GUARD_ARROW : "->>" > }

//Comments
SKIP : { < "#" (~["\r", "\n"])* > }
SKIP : { < "###" (~["#"])* "###" > }

//Whitespace
SKIP : { "\n" | "\r" | " " }

/** Main endpoint */
Object input() throws Exception : { Object expression; Object result; } {
  expression = expression()
  <EOF>
  {
    System.out.println();
    System.out.println("Finished parsing file.");
    System.out.println("Preparing to evaluate result");
    if(expression instanceof FL_IncludedSet) {
    	System.out.println("FL_Included set discovered, building scope tree & evaluating");
    	FL_IncludedSet flIS = (FL_IncludedSet) expression;
    	result = evaluate(flIS.set, flIS.expression);
    } else {
		System.out.println(expression);
		result = evaluate(new FL_Set(), expression);
    }

    System.out.println("Final result: " + result);
  	return result;
  }
}

Token anyOperator() throws Exception : { Token op; } {
	  op = <BOOLEAN_OP>    { return op; }
	| op = <OP>            { return op; }
	| op = <SET_OP>        { return op; }
	| op = <COMPARATOR_OP> { return op; }
}

FL_IncludedSet includedSet() throws Exception : { FL_IncludedSet result; Object expression; FL_Set set; } {
  	{ result = new FL_IncludedSet(); }
	<INCLUDE>
	set = set()
	<IN>
	expression = expression()

	{
	  result.set = set;
	  result.expression = expression;
	  return result;
	}
}

FL_Set set() throws Exception : { FL_Set set; Token setDeclaration; Token attrName; Object attrValue; } {
  	{ set = new FL_Set(); }
	(
	  <IMPURE>
	  { set.impure = true;}
	)?
	setDeclaration = <OPENCBRACKET>
	(
	  attrName = <VAR_NAME>
	  <EQUALS>
	  attrValue = functionResult()
	  {
	    if(set.attributes.containsKey(attrName.image)) {
			System.out.println("'" + attrName.image + "' already exists in the set... overriding");
	    }
	    set.attributes.put(attrName.image, attrValue);

	    //Extra purity checks
	    if(attrValue instanceof FL_Function) {
			/*
				For example, this code is invalid:
				  print' = x -> @print "hello";
				Because it calls the impure function @print.
				This means that print' should be @print' to
				maintain impurities
			*/
	    }
	    
	  }
	)*
	<CLOSECBRACKET>
	{
	  set.checkPurity(setDeclaration);
	  return set;//print(set); //TODO: Remove this
	}
}

FL_Enum enumeration() throws Exception : { FL_Enum flEnum; Token element; } {
    { flEnum = new FL_Enum(); }
	<ENUM_OPEN>
	
	element = <CAPS>
	{ flEnum.elements.add(element.image); }

	(
	  <COMMA>
	  element = <CAPS>
	  { flEnum.elements.add(element.image); }
	)*

	<ENUM_CLOSE>
	{ return flEnum; } 
}

Object functionResult() throws Exception : { Object result; } {
	(
	  LOOKAHEAD(2)
	    result = lambda()
	  | result = expression()
	  | result = enumeration()
	  | result = matches()
	)
	<SEMICOLON>

	{ return result; }
}

FL_Function lambda() throws Exception : { FL_Function.FL_Function_Builder function; Token paramName; Object innerExpression; } {
	{ function = new FL_Function.FL_Function_Builder(); }
	
	(
	  LOOKAHEAD(3)
	  paramName = <VAR_NAME>
	  { function.parameters.push(paramName.image); }
	  <FUNCTION_ARROW>
	)+

	(
	    innerExpression = expression()
	  | innerExpression = matches()
	)

	{
	  function.expression = innerExpression;
	  return function.build();
	}
}

List<Object> list() throws Exception : { List<Object> list; Object nextItem; } {
	{ list = new LinkedList<Object>(); }

  	//Open bracket
  	<OPENSBRACKET> (
  	  
		//Empty list		<CLOSESBRACKET> { return list; }
		|
		//Non-empty list
		nextItem = enclosedExpression()
		{ list.add(nextItem); }
		
		(LOOKAHEAD(2) <COMMA>
			nextItem = enclosedExpression()
			{ list.add(nextItem); }
		)*
		<CLOSESBRACKET>
	)
	{ return list; }
}

Object enclosedExpression() throws Exception : { Object result; } {
	(
	  <OPENBRACKET>
	  result = expression()
	  <CLOSEBRACKET>
	   { return result; }
	)
	| result = singleExpression() { return result; }
}

double number() throws Exception : { Token value; double f; } {
	  value = <NUMBER> 				  { return Double.valueOf(value.image); }
	| value = <FLOATING_POINT_NUMBER> { return Double.valueOf(value.image); }
}

/** Expressions */
Object expression() throws Exception : { Object result; } {    
  	  result = variableExpression() { return result; }
	| result = setExpression()      { return result; }
	| result = includedSet()        { return result; }
	| result = listExpression()     { return result; }
	| result = numberExpression()   { return result; }
	| result = stringExpression()   { return result; }
	| result = booleanExpression()  { return result; }
	| builtinFunctions()            { return "builtin"; }
	| result = guards()             { return result; }
}

Object variableExpression() throws Exception : { Object result; Token varName; } {
  	  LOOKAHEAD(2) result = lambda() { return result; }
	  | varName = <VAR_NAME> (
		result = functionCall(varName) { return result; }
		| <SELECT> (
		  <CAPS> { return null; }
		  | <VAR_NAME> (<SELECT> (<VAR_NAME>|<CAPS>))* { return "enum selection"; }
		)
		| result = variableOperator(varName) { return result; }
	  )
}

// <VARNAME> <OP> <EXPRESSION> 
FL_VarOp variableOperator(Token varName) throws Exception : { Token operator; Object expr; FL_VarOp varop; } {
  	{
  	  varop = new FL_VarOp();
  	  varop.initVar = new FL_Var(varName.image);
  	}
	(
	  LOOKAHEAD(2)
	  operator = anyOperator()
	  { varop.operators.add(operator); }
	  (
	    LOOKAHEAD(3)
	      expr = expression()         { varop.expressionsToParse.add(expr); }
	    | expr = enclosedExpression() { varop.expressionsToParse.add(expr); }
	  )
	)*
	{
	  return varop;
	}
} 

FL_Function_Call functionCall(Token varName) throws Exception : { FL_Function_Call result; Object param; } {
  	{
  	   	result = new FL_Function_Call();
		result.functionName = new FL_Var(varName.image);
  	}
  	
	(
	  LOOKAHEAD(2)
	    param = singleExpression()   { result.arguments.add(param); }
	  | param = enclosedExpression() { result.arguments.add(param); }
	)+

	{ return result; }
}

Object stringExpression() throws Exception : { Token initString; Token nextToken; StringBuilder builder; FL_Set setExistance; } {
	initString = <STRING>
	{ builder = new StringBuilder(parseString(initString)); }
	(
	    <CONTAINS> (
	        setExistance = set() /*TODO: |<VAR_NAME> */
		) { return setExistance.attributes.containsKey(parseString(initString)); }
	    |
	    (
	      LOOKAHEAD(2)
	      <CONCAT>
	      nextToken = <STRING> //TODO: This could ... just not be a String.
	      { builder.append(parseString(nextToken)); }
	    )* { return builder.toString(); }
	)
}

Object setExpression() throws Exception : {
  FL_Set initSet; Token setParam; Object accessed;
  FL_Set secondSet; Token setOp;
} {
	initSet = set()
	{ accessed = initSet; }
	(
	  (
	    <SELECT>
	    setParam = <VAR_NAME>
	    {
	      	if(accessed instanceof FL_Set) {
				accessed = ((FL_Set) accessed).attributes.get(setParam.image);
	    	} else {
				throw new Exception ("Tried to access element " + setParam.image + " from something that's not a set" + location(setParam));
	    	}	
	    }
	  )+ { return accessed; } //Set accessing
	  | (
	    LOOKAHEAD(2)
	    setOp = <SET_OP>
	    secondSet = set()
	    {
	      initSet = new OperatorParser(setOp).applySetObjects(initSet, secondSet);
	    }
	  )* { return initSet; } //"set operations"
	)
}

double numberExpression() throws Exception : { double acc; Token op; double next; } {
	acc = number()
	(
	  LOOKAHEAD(2)
	  op = <OP>
	  next = number()
	  {
		 acc = new OperatorParser(op).applyDouble(acc, next);
	  }
	)*
	{ return acc; }
}

boolean booleanExpression() throws Exception : { Token first; boolean acc; Token op; Token next; } {
  	first = <BOOLEAN>
	{ acc = Boolean.parseBoolean(first.image); }
	(
	  LOOKAHEAD(2)
	  op = <BOOLEAN_OP>
	  next = <BOOLEAN>
	  {
		 acc = new OperatorParser(op).applyBoolean(acc, Boolean.parseBoolean(next.image));
	  }
	)*
	{ return acc; }
}

List<Object> listExpression() throws Exception : { List<Object> list; Object expr; } {
    list = list()
    (
      LOOKAHEAD(2)
      <CONCAT>
      expr = expression()
      {
      	if(expr instanceof List) {
			list.addAll((List) expr);
      	} else {

			/*TODO: Say expr is an instanceof FL_Guards, which evaluates to a list.
			These need to be properly evaluated before concatenation is declared,
			so return type should be something like a "completeable future", which
			SHOULD return a list */
      	  	
      	  	//TODO: Handle list concat with new stuff
			//throw new Exception("Tried to concat a list with unknown expression");
      	}
      }
    )*
	{ return list; }
}

void builtinFunctions() throws Exception : {} {
	<IMPORT>  (<STRING> | <VAR_NAME>)
    | <PRINT> (<STRING> | <VAR_NAME>)
	| <EXEC>  (<STRING> | <VAR_NAME>)
}

Object singleExpression() throws Exception : { Object result; Token token; } {
	  result = set() { return result; }
	| token = <VAR_NAME> { return new FL_Var(token.image); }
	| result = list() { return result; }
	| result = number() { return result; }
	| token = <STRING> { return parseString(token); }
	| token = <BOOLEAN> { return Boolean.parseBoolean(token.image); }
}

FL_Matches matches() throws Exception : { FL_Matches matches; } {
	{ matches = new FL_Matches();}
  
	<MATCH> <VAR_NAME> 
	(LOOKAHEAD(2) <GUARD> expression() <GUARD_ARROW> expression())+
	(LOOKAHEAD(2) <GUARD> <GUARD_ARROW> expression())?

	{ return matches; }
}

FL_Guards guards() throws Exception : { FL_Guards guards; Object predicate; Object expression; Object finalExpression; Token firstGuard; } {
	{ guards = new FL_Guards(); }
  
	(firstGuard = <GUARD>
		predicate = expression()
		<GUARD_ARROW>
		expression = expression()
		try { 
			<GUARD>
		} catch(ParseException e) {
			System.err.println("Guards doesn't have a default case, for example:\n  | ->> ...\n" + location(firstGuard));
			System.exit(0);
		}
		{ guards.statements.put(predicate, expression); }
	)+
	(
	  	<GUARD_ARROW>
	  	finalExpression = expression()
	  	{ guards.finalStatement = finalExpression; }

	  	
	)

	{ return guards; }
}
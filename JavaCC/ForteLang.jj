options {
	STATIC = false;
}

PARSER_BEGIN(ForteLang)

import java.util.LinkedList;
import java.util.HashMap;
import java.util.ListIterator;
import java.util.Stack;
import java.util.LinkedHashMap;
import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;

import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;

import java.util.regex.Pattern;

public class ForteLang {
	
	/** Static fields */
	static String fileName;
	final static boolean LOGGING_ENABLE = true; 

	static void printSECD() {print("SECD"); }
	static void printSECD(Object o) { print("SECD", o); }
	static void printSECD(String s, Object o) { print("SECD", s, o); }

	static void printEVAL() {print("EVAL"); }
	static void printEVAL(Object o) { print("EVAL", o); }
	static void printEVAL(String s, Object o) { print("EVAL", s, o); }
	
	static void print(String title) { print(title, "", ""); }
	static void print(String title, Object val) { print(title, "", val); }
	static void print(String title, String init, Object val) {
	  	if(LOGGING_ENABLE) {
		  	System.out.println("[" + title + "] " + init + (init.isEmpty() ? "" : " ") + String.valueOf(val));
	  	}
	}

	/** Main method */
	public static void main(String[] args) throws ParseException, FileNotFoundException {
	  	if(args.length != 1) {
	  	  	System.out.println("Usage: java ForteLang <File>");
			return;
	  	}

	  	File file = new File(args[0]);
	  	fileName = file.getName();
		try {
		  	/* Run the parser */

			Object result = new ForteLang(new FileInputStream(file)).input();
			if(result instanceof Double) {
			  	double d = (double) result;
				if((d % 1) == 0) {
					result = (long) d;
				}
			}
			System.out.println();
			System.out.println("=== Evaluation complete ===");
			System.out.println("==> " + result);
			
		} catch(Exception e) {
		  	e.printStackTrace();
		  	return;
		}
	}

	static class EvaluationException extends Exception {
		public EvaluationException(String message) {
			super(message);
		}
	}

	static interface Evaluatable { }

	/** Class declarations */

	//Function declaration, e.g. x -> y -> x + y
	static class FL_Function implements Evaluatable {
	  	//Basically the closure of parameters
	  	Map<String, Object> functionScope; 
		String parameter;
		Object expression;

		public FL_Function() {
			functionScope = new HashMap<String, Object>();
		}

		@Override public String toString() { return "FL_Function(" + parameter + ") -> (" + expression + ")"; }

		static class FL_Function_Builder {
			Stack<String> parameters;
			Object expression;
		  
			public FL_Function_Builder() {
				parameters = new Stack<String>();
			}

			public FL_Function build() {
			  	Object currentExpression = expression;
			  	while(!parameters.empty()) {
					FL_Function newExpression = new FL_Function();
					newExpression.parameter = parameters.pop();
					newExpression.expression = currentExpression;
					currentExpression = newExpression;
			  	}
				return (FL_Function) currentExpression;
			}
		}
	}

	//Function call, e.g. myFunc 2 3
	static class FL_Function_Call implements Evaluatable {
		Object initFunction;
		LinkedList<Object> arguments;

		public FL_Function_Call() {
			arguments = new LinkedList<Object>();
		}

//		@Override public String toString() { return "FuncCall " + initFunction + " " + arguments; }
	}

	static class FL_Set implements Evaluatable {
		boolean impure;
		LinkedHashMap<String, Object> attributes;

		public FL_Set() {
		  attributes = new LinkedHashMap<String, Object>();
		  impure = false;
		}

		public FL_Set clone() {
			FL_Set newSet = new FL_Set();
			newSet.impure = impure;
			newSet.attributes = new LinkedHashMap<String, Object>(attributes);
			return newSet;
		}

		public void checkPurity(Token setDeclaration) throws Exception {
		  //TODO: Make this code WAY more elegant, like seriously... what even
			if(!impure) {
				for(String str: attributes.keySet()) {
					if(str.startsWith("@")) {
						throw new Exception("impure set detected and isn't declared as 'impure'");
					}
				}
				
				for(Object o : attributes.values()) {
					if(o instanceof FL_Set) {
						if(((FL_Set) o).impure) {
							throw new Exception("Set detected as impure due to inner attribute and isn't declared as 'impure'" + location(setDeclaration));
						}
					}
				}
			} else {
				for(String str: attributes.keySet()) {
					if(str.startsWith("@")) {
						return;
					}
				}
				for(Object o : attributes.values()) {
					if(o instanceof FL_Set) {
						if(((FL_Set) o).impure) {
							return;
						}
					}
				}
				throw new Exception("impure keyword detected, but the set is actually pure" + location(setDeclaration));
			}
		}

		public boolean isImpure() {
			for(String str: attributes.keySet()) {
				if(str.startsWith("@")) {
					return true;
				}
			}
			
			for(Object o : attributes.values()) {
				if(o instanceof FL_Set) {
					if(((FL_Set) o).impure) {
						return true;
					}
				}
			}
			return false;
		}

		@Override public String toString() {
		  return (impure ? "Impure" : "") + "Set" + attributes;
		}
	}

	/** Helper functions */

	static String location(Token token) {
 		return " (Line " + token.beginLine + " in " + fileName + ")";
	}

	static String parseString(Token str) {
		return str.image.substring(1, str.image.length() - 1);
	}

	/** Other declared objects */

	static class FL_List implements Evaluatable {
		LinkedList<Object> list;
		public FL_List() { list = new LinkedList<Object>(); }
		
		@Override public String toString() {
		  return "List" + list;
		}

		@Override public boolean equals(Object o) {
			if(o instanceof FL_List) {
				FL_List other = (FL_List) o;
				return list.equals(other.list);
			}
			return false;
		}
	}

	static class FL_Guards implements Evaluatable {
		LinkedHashMap<Object, Object> statements;
		Object finalStatement;

		public FL_Guards() { statements = new LinkedHashMap<Object, Object>(); }

		@Override public String toString() {
		  StringBuilder builder = new StringBuilder("Guard{ ");
		  for(Entry<Object, Object> entry : statements.entrySet()) {
		      builder.append("| ");
			  builder.append(entry.getKey());
			  builder.append(" ->> ");
			  builder.append(entry.getValue());
			  builder.append(" ");
		  }
		  builder.append("| ->> ");
		  builder.append(finalStatement);
		  return builder.append(" }").toString();
		}
	}

	static class FL_Match implements Evaluatable {
		LinkedHashMap<Object, Object> statements;
		Object finalStatement;
		Object matchOn;

		public FL_Match() { statements = new LinkedHashMap<Object, Object>(); }

		@Override public String toString() {
		  return "FL_Match[stmts=" + statements + ", finalStmt=" + finalStatement + "]";
		}
	}

	static class FL_IncludedSet implements Evaluatable {
		FL_Set set;
		Object expression;

		@Override public String toString() {
		  return "FL_IncludedSet[set=" + set + ", expr=" + expression + "]";
		}
	}

	static class FL_Var implements Evaluatable {
		String name;

		public FL_Var(String name) {
			this.name = name;
		}

		@Override public String toString() {
		  return "Var[" + name + "]";
		}
	}

	static class FL_OpExpr implements Evaluatable {
		Object leftExpr;
		Object rightExpr;
		Token operator;
		
		public FL_OpExpr() {}

		@Override public String toString() {
		  StringBuilder builder = new StringBuilder("FL_OpExpr[");
		  builder.append(leftExpr);
		  builder.append("");
		  builder.append(operator.image);
		  builder.append("");
		  builder.append(rightExpr);
		  return builder.append("]").toString();
		}
	}

	static class FL_Builtin implements Evaluatable {
		Object param;
		enum Builtin { IMPORT, PRINT, EXEC, HEAD, TAIL }

		Builtin type;

		public FL_Builtin(Builtin type, Object param) {
			this.type = type;
			this.param = param;
		}
	}

	static class OperatorParser {

		enum Operator { BOOLEAN, NUMERICAL, SET, COMPARATOR, CONCAT };

		Operator operatorKind;
		String op;
	  
		public OperatorParser(Token operator) throws Exception {
			switch(operator.kind) {
				case ForteLangConstants.BOOLEAN_OP:
					operatorKind = Operator.BOOLEAN;
					break;
				case ForteLangConstants.OP:
					operatorKind = Operator.NUMERICAL;
					break;
				case ForteLangConstants.SET_OP:
					operatorKind = Operator.SET;
					break;
				case ForteLangConstants.COMPARATOR_OP:
					operatorKind = Operator.COMPARATOR;
					break;
				case ForteLangConstants.CONCAT:
					operatorKind = Operator.CONCAT;
					break;
				default:
					throw new Exception ("Invalid operator for OperatorParser: " + operator.image);
			}
			op = operator.image;
		}

		public Object apply(Object o1, Object o2) throws Exception {
			switch(operatorKind) {
				case BOOLEAN:
					return applyBoolean((boolean) o1, (boolean) o2);
				case NUMERICAL:
					return applyDouble((double) o1, (double) o2);
				case SET:
					return applySetObjects((FL_Set) o1, (FL_Set) o2);
				case COMPARATOR:
					return applyComparator(o1, o2);
				case CONCAT:
					return applyConcat(o1, o2); 
			}
			throw new Exception ("Failed to apply any operators");
		}

		public Object applyConcat(Object o1, Object o2) throws Exception {
		  	if(o1 instanceof FL_List && o2 instanceof FL_List) {
		  	  	FL_List l1 = (FL_List) o1;
		  	  	FL_List l2 = (FL_List) o2;
				l1.list.addAll(l2.list);
				return l1;
			} else if(o1 instanceof String && o2 instanceof String) {
				String s1 = (String) o1;
				String s2 = (String) o2;
				return s1 + s2;
			} else {
				throw new Exception("Cannot concatenate " + o1.getClass().getName() + " with " + o2.getClass().getName());
			}
		}

		public boolean applyComparator(Object o1, Object o2) throws Exception {
			switch(op) {
				case ">":
					return (double) o1 > (double) o2;
				case "<":
					return (double) o1 < (double) o2;
				case "<=":
					return (double) o1 <= (double) o2;
				case ">=":
					return (double) o1 >= (double) o2;
				case "==":
					return o1.equals(o2);
				case "!=":
					return !o1.equals(o2);
			}
			throw new Exception ("Invalid operator (expected comparator operator");
		}

		public double applyDouble(double f1, double f2) throws Exception {
			if(operatorKind != Operator.NUMERICAL) {
				throw new Exception("Invalid operator (expected numerical operator)");
		  	}

			switch(op) {
				case "+":
					return f1 + f2;
				case "*":
					return f1 * f2;
				case "-":
					return f1 - f2;
				case "/":
					return f1 / f2;
				case "%":
					return (int) f1 % (int) f2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public boolean applyBoolean(boolean b1, boolean b2) throws Exception {
			if(operatorKind != Operator.BOOLEAN) {
				throw new Exception("Invalid operator (expected boolean operator)");
		  	}
			switch(op) {
				case "||":
					return b1 || b2;
				case "&&":
					return b1 && b2;
			}
			throw new Exception("Invalid operator " + op);
		}

		public FL_Set applySetObjects(FL_Set s1, FL_Set s2) throws Exception {
			if(operatorKind != Operator.SET) {
				throw new Exception("Invalid operator (expected set operator)");
		  	}

			FL_Set newSet = new FL_Set();
			newSet.attributes = new LinkedHashMap<String, Object>(s1.attributes);
		  	
			switch(op) {
			  	//union
				case "/+": {
				  	newSet.impure = (s1.impure || s2.impure);
				  	newSet.attributes.putAll(s2.attributes);
					break;
				}
				//intersect
				case "/-": {
				  	newSet.attributes.putAll(s1.attributes);
				  	newSet.attributes.keySet().retainAll(s2.attributes.keySet());
				  	for(String key : newSet.attributes.keySet()) {
						newSet.attributes.put(key, s1.attributes.get(key));
				  	}
				  	newSet.impure = newSet.isImpure(); 
					break;
				}
				//difference
				case "//": {
				  	for(String key : s2.attributes.keySet()) {
						newSet.attributes.remove(key);
				  	}
				  	newSet.impure = newSet.isImpure(); 
					break;
				}
			}
			return newSet;
		} 
	}

	static class Dump {
		Stack<Object> stack;
		LinkedList<Object> control;
		HashMap<String, Object> environment;

		public Dump(Stack<Object> s, LinkedList<Object> control, HashMap<String, Object> env) {
			this.stack = s;
			this.control = control;
			this.environment = env;
		}
	}

	//Placeholder for "applying" an object
	static class ApplyObj { @Override public String toString() { return "ap"; }}

	public static Object secd(FL_Function_Call functionCall, FL_Set globalScope) throws Exception {
	  	Stack<Object> stack = new Stack<Object>();
	  	HashMap<String, Object> environment = new HashMap<String, Object>();
	  	environment.putAll(globalScope.attributes); //TODO: Make sure this isn't busted
	  	LinkedList<Object> control = new LinkedList<Object>();
	  	Stack<Dump> dump = new Stack<Dump>();

	  	//Convert to reverse polish
		control.add(functionCall.initFunction);
		for(Object object : functionCall.arguments) {
			control.add(object);
			control.add(new ApplyObj());
		}
		printSECD("Initial control: ", control);

		Object controlItem = null;

		do {
			while(!control.isEmpty()) {
				controlItem = control.pop();

	
				if(controlItem instanceof ApplyObj) {
					//Begin application
					printSECD();
					printSECD("Applying...");
	
					//Pop two items from the top of the stack
					Object value = stack.pop();

					Object potentialFunction = stack.pop();
					
					FL_Function lambda = null;
					if(potentialFunction instanceof FL_Function) {
						lambda = (FL_Function) potentialFunction;
					} else if(potentialFunction instanceof FL_Function_Call) {
						FL_Function_Call lambdaCall = (FL_Function_Call) potentialFunction;
						lambda = (FL_Function) lambdaCall.initFunction;
					}
					
	
					//Bind it properly in the current environment
					environment.put(lambda.parameter, value);
					Object result = lambda.expression;

					printSECD("Added complete. Result: ", result);
	
					//If the result is an abstraction, dump it
					if(result instanceof FL_Function) {
					    //Dump
					  	printSECD("Beginning dump...");
						Dump newDump = new Dump((Stack<Object>) stack.clone(), (LinkedList<Object>) control.clone(), (HashMap<String, Object>) environment.clone());
						dump.push(newDump);
			
						stack.clear();
						control.clear();
						environment.clear();
			
						control.add(result);
					} else {
					  	//Push result on the stack
						stack.push(result);
					}
				} else {
					//If it's a FL_Var, evaluate it
					if(controlItem instanceof Evaluatable && !(controlItem instanceof FL_Function)) {
					  	//TODO: Check here - this might not be properly evaluating the inputs	
						controlItem = evaluate(globalScope, controlItem);
					}
					//Otherwise, don't. Push the control item on the stack
					stack.push(controlItem);
				}
			}

			if(!dump.isEmpty()) {
			  	printSECD("Restoring from dump");
			  	Dump restoredDump = dump.pop();

			  	while(!stack.isEmpty()) {
					restoredDump.stack.push(stack.pop());
			  	}

			  	stack = restoredDump.stack;
			  	control = restoredDump.control;
			  	environment.putAll(restoredDump.environment);
			  	printSECD("Dump restored");
			}

		} while(!control.isEmpty() || !dump.isEmpty());

		FL_Set newEnv = new FL_Set();
		newEnv.attributes.putAll(environment);
		return evaluate(newEnv, stack.pop());
	}
	
	public static Object evaluate(FL_Set scope /*TODO: Why is this a FL_Set not a hashmap?*/, Object expression) throws Exception {
	  	scope = scope.clone();
//		System.out.println(scope);
	  	if(expression instanceof Evaluatable) {
			printEVAL("Evaluating ", expression);
	  	  	//System.out.println(expression.getClass().getName());
//	  	  	System.out.println(expression);
	  	  	
	  	  	if(expression instanceof FL_Builtin) {
				FL_Builtin builtin = (FL_Builtin) expression;
				Object builtinParam = evaluate(scope, builtin.param);
				switch(builtin.type) {
					case IMPORT:
						File file = new File((String) builtinParam);
						return new ForteLang(new FileInputStream(file)).input();
					case PRINT:
						System.out.println((String) builtinParam);
						return builtinParam;
					case EXEC:
						break;
					case HEAD:
						if(!(builtinParam instanceof FL_List)) {
							throw new EvaluationException("head function requires a list as a parameter");
						} else {
						  	LinkedList list = ((FL_List) builtinParam).list;
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the head of the list");
						  	}
						  	return list.getFirst();
						} 
					case TAIL:
						if(!(builtinParam instanceof FL_List)) {
							throw new Exception("tail function requires a list as a parameter");
						} else {
						 	LinkedList list = ((FL_List) builtinParam).list;
						  	if(list.isEmpty()) {
								throw new EvaluationException("List is empty, cannot retrieve the tail of the list");
						  	}
						  	list = (LinkedList) list.clone();
						  	list.remove();
						  	FL_List newList = new FL_List();
						  	newList.list = list;
						  	return newList;
						}
//						TODO: 
//					
//					    ### Things to do
//					    all = list -> false; 
//					    filter = list -> [];
//					    foldl = op -> init -> list -> 2;
//					    length = list -> 0;
//					    map = list;
//					    ###
				}
	  	  	  
			} else

			if(expression instanceof FL_Function) {
			  	FL_Function function = (FL_Function) expression;
			  	FL_Function_Call newFunctionCall = new FL_Function_Call();
			  	newFunctionCall.initFunction = function;
			  	
				return newFunctionCall;
			} else
			if(expression instanceof FL_Function_Call) {
				printEVAL();
				FL_Function_Call call = (FL_Function_Call) expression;

				if(!(call.initFunction instanceof FL_Function)) {
				  	// It's a function name, which needs to be resolved
				  	FL_Var functionName = (FL_Var) call.initFunction; 
					Object function = scope.attributes.get(functionName.name);

					if(function == null) {
						throw new Exception("Function \"" + functionName.name + "\" has not been declared!");
					} else {
						if(function instanceof FL_Function_Call) {
							call.initFunction = ((FL_Function_Call) function).initFunction;
						} else {
							printEVAL("Reading from closure... ", function.getClass().getName());
						}
					}
				}
				
				if(call.arguments.isEmpty()) {
//				  	System.out.println("Evaluating because arguments are empty...");
					return evaluate(scope, call.initFunction);
				}

				
				
				if(call.initFunction instanceof FL_Function) {
					printEVAL("About to evaluate the following: ");
					printEVAL(call.initFunction);

					printEVAL();
					printEVAL("Starting SECD machine");
					printEVAL();

					return secd(call, scope);
					
//					System.out.println("With parameters " + call.arguments);
//					while(function instanceof FL_Function) {
//					  	FL_Function func = (FL_Function) function;
//						scope.attributes.put(func.parameter, call.arguments.pop());
//						function = func.expression;
//					}
//					System.out.println("Applied parameters");
//					System.out.println(function);
//					return evaluate(scope, function);
				} else {
				  	printEVAL("Avoiding the SECD machine, because of type ", call.initFunction.getClass().getName());
				  	if(call.initFunction instanceof Evaluatable) {
						return evaluate(scope, call.initFunction);
				  	} else {
						return call.initFunction;
				  	}
				}

			} else if(expression instanceof FL_Guards) {
				FL_Guards guards = (FL_Guards) expression;
				for(Object guardExpr : guards.statements.keySet()) {
					Object result = evaluate(scope, guardExpr);
					if(result instanceof Boolean) {
						boolean resultBool = (boolean) result;
						if(!resultBool) {
							continue;
						} else {
							return evaluate(scope, guards.statements.get(guardExpr));
						}
					} else {
						throw new Exception(result + " is not a valid Boolean object in guard expression!");
					}
				}
				return evaluate(scope, guards.finalStatement);
			} else if(expression instanceof FL_Match) {
				FL_Match match = (FL_Match) expression;

				Object matchOn = evaluate(scope, match.matchOn);
				
				for(Object matchExpr : match.statements.keySet()) {
					Object result = evaluate(scope, matchExpr);

					if(result instanceof Pattern && matchOn instanceof String) {
						Pattern pattern = (Pattern) result;
						if(pattern.matcher((String) matchOn).matches()) {
							return evaluate(scope, match.statements.get(matchExpr));
						}
					} else if(matchOn.equals(result)) {
						return evaluate(scope, match.statements.get(matchExpr));
					}
				}
				return evaluate(scope, match.finalStatement);
			}else if(expression instanceof FL_Var) {
				FL_Var flVar = (FL_Var) expression;
				Object var = scope.attributes.get(flVar.name);
				while(var instanceof FL_Var) {
					var = scope.attributes.get(((FL_Var)var).name);
				}
				if(var == null) {
					throw new Exception("Could not find function \"" + flVar.name + "\" in the program!");
				}
				if(var instanceof FL_Function) {
					printEVAL("\"" + flVar.name + "\" evaluates to a lambda, therefore not resolving");
					return var;
				} else { 
					printEVAL("Resolving: " + flVar.name + " => ", var);
					return evaluate(scope, var);
				}
			} else if(expression instanceof FL_OpExpr) {
				FL_OpExpr flVarOp = (FL_OpExpr) expression;

				printEVAL("\n\nAbout to evaluate OpExpr:");
				printEVAL(flVarOp);
				
			  	Object left = flVarOp.leftExpr;
			  	Object right = flVarOp.rightExpr;

			  	if (left instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr left part", left);
					left = evaluate(scope, left);
			  	}

			  	if (right instanceof Evaluatable) {
			  	  	printEVAL("EvalOpExpr right part", right);
					right = evaluate(scope, right);
			  	}

				Token operatorToUse = flVarOp.operator;

				printEVAL("OpExpr to eval: " + left + " " + operatorToUse.image + " " + right);
			  	
			  	Object newInit = new OperatorParser(operatorToUse).apply(left, right);

			  	printEVAL("OpExpr eval result: ", newInit);
			  	return newInit;

//			  	if(flVarOp.expressionsToParse.isEmpty()) {
//					return evaluate(scope, newInit);
//			  	} else {
//					FL_OpExpr newOp = new FL_OpExpr();
//					newOp.initVar = newInit;
//					newOp.operators = flVarOp.operators;
//					newOp.expressionsToParse = flVarOp.expressionsToParse;
//					return evaluate(scope, newOp);
//			  	}
			} else if(expression instanceof FL_List) {
				FL_List list = (FL_List) expression;
				ListIterator<Object> iterator = list.list.listIterator(0);
				while(iterator.hasNext()) {
					Object expr = iterator.next();
					iterator.set(evaluate(scope, expr));
				}
				return list;
			} else if(expression instanceof FL_Set) {
			  	// TODO: Handle purity tests here!
				return expression;
			} else if(expression instanceof FL_IncludedSet) {
			  	FL_IncludedSet incSet = (FL_IncludedSet) expression;
				scope.attributes.putAll(incSet.set.attributes);
				return evaluate(scope, incSet.expression);
			}
			throw new Exception("Not implemented yet, could not evaluate: " + expression);
	  	} else {
//	  	  if(expression instanceof Double) {
//			double d = (double) expression;
//			if((d % 1) == 0) {
//				return (long) d;
//			}
//	  	  }	
	  	  return expression;
	  	}
	}

}

PARSER_END(ForteLang)

//Operators
TOKEN : { < COMPARATOR_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" > }
TOKEN : { < BOOLEAN_OP : "||" | "&&" > }
TOKEN : { < SET_OP : "/+" | "/-" | "//" > }
TOKEN : { < OP : "+" | "*" | "-" | "/" | "%" > }
TOKEN : { < CONCAT : "++" > }
TOKEN : { < SELECT : "." > }
TOKEN : { < CONTAINS : "?" > }

//Data types
TOKEN : { < NUMBER : ("-")? (["0"-"9"])+ > }
TOKEN : { < FLOATING_POINT_NUMBER : <NUMBER>"."<NUMBER> > }
TOKEN : { < BOOLEAN : "true" | "false" > } 
TOKEN : { < STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >}
TOKEN : { < REGEX_STRING : "'" ("\\" ~[] | ~["'", "\\"])* "'" >}

//Keywords
TOKEN : { < INCLUDE : "include" > }
TOKEN : { < IN : "in" > }
TOKEN : { < IMPURE : "impure" > }
TOKEN : { < MATCH : "match" > }

//Built-in functions
TOKEN : { < IMPORT : "@import" > }
TOKEN : { < EXEC : "@exec" > }
TOKEN : { < PRINT : "@print" > }
TOKEN : { < HEAD : "head" > }
TOKEN : { < TAIL : "tail" > }

//Brackets
TOKEN : { < OPENBRACKET : "(" > }
TOKEN : { < CLOSEBRACKET : ")" > }

//Lists
TOKEN : { < OPENSBRACKET : "[" > }
TOKEN : { < CLOSESBRACKET : "]" > }
TOKEN : { < COMMA : "," > }

//Enums
TOKEN : { < CAPS : (["A"-"Z", "_"])+ > }
TOKEN : { < ENUM_OPEN : " {|" > }
TOKEN : { < ENUM_CLOSE : "|}" > }

//Sets
TOKEN : { < EQUALS : "=" > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < OPENCBRACKET : "{" > }
TOKEN : { < CLOSECBRACKET : "}" > }

//Functions
TOKEN : { < VAR_NAME : ["A"-"Z", "a"-"z", "@"] (["A"-"Z", "a"-"z", "0"-"9", "'"])* > }
TOKEN : { < FUNCTION_ARROW : "->" > }
TOKEN : { < GUARD_START : "|>" > }
TOKEN : { < GUARD : "|" > }
TOKEN : { < GUARD_ARROW : "->>" > }

//Comments
SKIP : { < "#" (~["\r", "\n"])* > }
SKIP : { < "###" (~["#"])* "###" > }

//Whitespace
SKIP : { "\n" | "\r" | " " }

/** Main endpoint */
Object input() throws Exception : { Object expression; Object result; } {
  expression = enclosedExpression()
  <EOF>
  {

	System.out.println();
	System.out.println("=== Parsing complete ===");
	System.out.println();
    
    if(expression instanceof FL_IncludedSet) {
    	FL_IncludedSet flIS = (FL_IncludedSet) expression;
    	return evaluate(flIS.set, flIS.expression);
    } else {
		return evaluate(new FL_Set(), expression);
    }
  }
}

Token anyOperator() throws Exception : { Token op; } {
	  op = <BOOLEAN_OP>    { return op; }
	| op = <OP>            { return op; }
	| op = <SET_OP>        { return op; }
	| op = <COMPARATOR_OP> { return op; }
	| op = <CONCAT>        { return op; }
}

FL_IncludedSet includedSet() throws Exception : { FL_IncludedSet result; Object expression; FL_Set set; } {
  	{ result = new FL_IncludedSet(); }
	<INCLUDE>
	set = set()
	<IN>
	expression = enclosedExpression()

	{
	  result.set = set;
	  result.expression = expression;
	  return result;
	}
}

FL_Set set() throws Exception : { FL_Set set; Token setDeclaration; Token attrName; Object attrValue; } {
  	{ set = new FL_Set(); }
	(
	  <IMPURE>
	  { set.impure = true;}
	)?
	setDeclaration = <OPENCBRACKET>
	(
	  attrName = <VAR_NAME>
	  <EQUALS>
	  attrValue = enclosedExpression()
	  <SEMICOLON>
	  { set.attributes.put(attrName.image, attrValue); }
	)*
	<CLOSECBRACKET>
	{
	  set.checkPurity(setDeclaration);
	  return set;
	}
}

FL_Function lambda() throws Exception : { FL_Function.FL_Function_Builder function; Token paramName; Object innerExpression; } {
	{ function = new FL_Function.FL_Function_Builder(); }

	(
		(			paramName = <VAR_NAME>
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
		)
		|
		(
			<OPENBRACKET>
			paramName = <VAR_NAME>
			<FUNCTION_ARROW>
			innerExpression = enclosedExpression()
			<CLOSEBRACKET>
		)
	)
	  
	{
	    function.parameters.push(paramName.image);
	    function.expression = innerExpression;
	    return function.build();
	}
}

FL_List list() throws Exception : { FL_List list; Object nextItem; } {
	{ list = new FL_List(); }

  	//Open bracket
  	<OPENSBRACKET> (
  	  
		//Empty list		<CLOSESBRACKET> { return list; }
		|
		//Non-empty list
		nextItem = enclosedExpression()
		{ list.list.add(nextItem); }
		
		(LOOKAHEAD(2) <COMMA>
			nextItem = enclosedExpression()
			{ list.list.add(nextItem); }
		)*
		<CLOSESBRACKET>
	)
	{ return list; }
}

double number() throws Exception : { Token value; double f; } {
	  value = <NUMBER> 				  { return Double.valueOf(value.image); }
	| value = <FLOATING_POINT_NUMBER> { return Double.valueOf(value.image); }
}

/** Expressions */
Object enclosedExpression() throws Exception : { Object result; Token vName;  } {
	LOOKAHEAD(3)
	result = opExpression() {return result; }
	| (
	  <OPENBRACKET>
	  result = opExpression() 
	  <CLOSEBRACKET>
	   { return result; }
	)
}

Object expression() throws Exception : { Object result; } {
    LOOKAHEAD(3) result = functionCall() { return result; }
	| result = singleExpression()       { return result; }
	
}

Object singleExpression() throws Exception : { Object result; Token token; } {
	  result = set() { return result; }
	| result = lambda() { return result; }
	| result = includedSet() { return result; }
	| result = list() { return result; }
	| result = number() { return result; }
	| result = guards() { return result; }
	| result = match() { return result; }
	| token = <STRING> { return parseString(token); }
	| token = <REGEX_STRING> { return Pattern.compile(parseString(token)); }
	| token = <BOOLEAN> { return Boolean.parseBoolean(token.image); }
	| result = builtinFunctions() { return result; }
}

Object opExpression() throws Exception : { FL_OpExpr result; Object expr; Token operator; boolean isOpExpr; } {
  	{
  	  	result = new FL_OpExpr();
  		isOpExpr = false;
  	}

  	expr = expression()
  	{ result.leftExpr = expr; }
	(
	  LOOKAHEAD(2)
	  operator = anyOperator()
	  { result.operator = operator; }

	  expr = enclosedExpression()
	  { result.rightExpr =expr; }

	  { isOpExpr = true; }
	)?
	{
		if(isOpExpr) {
		  	//TODO: Check for nested OpExprs here and
		  	//handle the order of operations.
			return result;
		} else {
			return expr;
		}
	}
}

FL_Function_Call functionCall() throws Exception : { FL_Function_Call result; Object param; Token varName; Object lambda; } {
  	{
		varName = null;
		lambda = null;
  	}
  	(
  	  LOOKAHEAD(2)
  	  lambda = lambda()  	  | varName = <VAR_NAME> 
  	)
  	{
  	   	result = new FL_Function_Call();
  	   	if(varName != null) { 
			result.initFunction = new FL_Var(varName.image);
		} else {
			result.initFunction = lambda;
		}
  	}
	(
	  LOOKAHEAD(2)
	  param = enclosedExpression()
	  { result.arguments.add(param); }
	)*
	{ return result; }
}

Object builtinFunctions() throws Exception : { Object param; Token stringToken; } {
	<IMPORT>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.IMPORT, param); }
    | <PRINT> param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.PRINT, param); }
	| <EXEC>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.EXEC, param); }
	| <HEAD>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.HEAD, param); }
	| <TAIL>  param = enclosedExpression() { return new FL_Builtin(FL_Builtin.Builtin.TAIL, param); }
}

FL_Guards guards() throws Exception : { FL_Guards guards; Object predicate; Object expression; Object finalExpression; } {
	{ guards = new FL_Guards(); expression = null; }
  	<GUARD_START>
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ guards.statements.put(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	finalExpression = enclosedExpression()
	{
	  guards.finalStatement = finalExpression;
	  return guards;
	}
}

FL_Match match() throws Exception : {
  FL_Match match;
  Object statement;
  
  Object predicate;
  Object expression;
  Object finalExpression;
} {
	{ match = new FL_Match(); expression = null; }

	<MATCH>
	statement = enclosedExpression()
	{ match.matchOn = statement; }
	(
	  	LOOKAHEAD(2)
	  	<GUARD>
		predicate = enclosedExpression()
		<GUARD_ARROW>
		expression = enclosedExpression()
		{ match.statements.put(predicate, expression); }
	)+
	<GUARD>
	<GUARD_ARROW>
	finalExpression = enclosedExpression()
	{
	  match.finalStatement = finalExpression;
	  return match;
	}
}
include {
    # Adds two parameters together
    add = x -> y -> x + y;

    basicOperation = 123.25 + 2;

    # Lists
    someList      = [1, 2];
    someOtherList = [3];
    emptyList     = [];

    #Example with guards
    maxOr0 = x -> y -> |>
        | x > y ->> x 
        | x < y ->> y 
        | ->> 0;

    nestedGuard = x -> |>
        | x == 0 ->> 0
        | ->> |>
            | x == 1 ->> 1
            | ->> -1;

    inlineMax = x -> y -> |>| x > y ->> x | x < y ->> y |->> 0;

    # Set operations
    union =      set1 -> set2 -> set1 /+ set2;
    intersect =  set1 -> set2 -> set1 /- set2;
    difference = set1 -> set2 -> set1 // set2;

    # Adds sets to scope of expressions
    myFunctions2 = include {
        myAdd = x -> y -> x + y;
    } in myAdd 2;

    head' = list -> list ++ [2, 3, (2 + 2)];

    nestedList = [2, [3]];

    const = 4;

    p = x -> x;

    a = lambda -> lambda 2 3;

    factorial = input -> |>
        | input == 0 ->> 1
        | ->> input * factorial (input - 1);

    # Standard library
    all = list -> match list 
        | [] ->> true
        | ->> |> | head list ->> all (tail list) | ->> false;

    any = list -> match list
        | [] ->> false
        | ->> |> | head list ->> true | ->> any (tail list);

    length = list -> match list
        | [] ->> 0
        | ->> 1 + sizeOfList (tail list);

    genList = num -> formula -> match num
        | 0 ->> []
        | ->> [(formula num)] ++ genList (num - 1) formula;

    not = bool -> |> | bool ->> false | ->> true;
            
    # Pattern matching on Strings:
    isInt = str -> match str
        | "I_AM_AN_INT" ->> true
        | '[0-9]+' ->> true
        | '-[0-9]+' ->> true
        | ->> false;

    isFloat = str -> match str
        | '-?[0-9]+\.[0-9]+' ->> true
        | ->> false;

    # isInt = str -> '[0-9]+';

    isEmpty = list -> match list
        | [] ->> true
        | ->> false;

    # map = list -> f -> match list
    #     | [] ->> []
    #     | ->> [f (head list)] ++ map (tail list) f;

    # map' = f -> list -> match list
    #     | [] ->> []
    #     | ->> [f (head list)] ++ map' f (tail list);

} in maxOr0 2 3
#factorial 5#impure {} // {a=2;} #impure { @a = 2; } ? "a"

#not false #genList 3 (x -> 2) 

#any [false, false, false] #all [true, true, true, true]

#map [1, 2, 3, 4, 5] (x -> 5) 

#map' (x -> 5)  [1, 2, 3]

#sizeOfList [1, 2, 3]

#factorial 5 #1 + 2 + 3 + 4 + 5 #factorial 2

#isEmpty (tail [2, 3, 4]) #@print "hi" #isInt "yo"# ("23" ++ "2.2")


#factorial 1

#maxOr0 (nestedGuard 2) -2

#union {} {}

#(x -> x -> x) 2 3

#(y -> (x -> y)) 2 3

#add 2 3

# a add 
#add ((x -> x) 2) 3

#add 2 3 #(x -> x) 2

#add (2) 3

#a add
#add (p 2) 3
#head' [] []
#head'
#head' [5, 6, 1, 0]
#add 1 2
#const + 10 #add (add 1 2) 3 #Expect 6 